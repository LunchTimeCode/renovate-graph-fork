{"version":3,"file":"pr-cache.js","sourceRoot":"","sources":["../../../../lib/modules/platform/gitea/pr-cache.ts"],"names":[],"mappings":";;;;AAAA,mCAAgC;AAChC,iCAAiC;AACjC,6EAAuD;AACvD,+DAA0D;AAG1D,2CAAoE;AAGpE,mCAAiD;AAEjD,MAAa,YAAY;IAIb;IACA;IAJF,KAAK,CAAmB;IAEhC,YACU,IAAY,EACZ,MAAqB;QADrB,SAAI,GAAJ,IAAI,CAAQ;QACZ,WAAM,GAAN,MAAM,CAAe;QAE7B,MAAM,SAAS,GAAG,IAAA,qBAAQ,GAAE,CAAC;QAC7B,SAAS,CAAC,QAAQ,KAAK,EAAE,CAAC;QAC1B,SAAS,CAAC,QAAQ,CAAC,KAAK,KAAK,EAAE,CAAC;QAChC,IAAI,gBAAgB,GAAG,SAAS,CAAC,QAAQ,CAAC,KAAK,CAAC,iBAEnC,CAAC;QACd,IAAI,CAAC,gBAAgB,IAAI,gBAAgB,CAAC,MAAM,KAAK,MAAM,EAAE,CAAC;YAC5D,gBAAgB,GAAG;gBACjB,KAAK,EAAE,EAAE;gBACT,UAAU,EAAE,IAAI;gBAChB,MAAM;aACP,CAAC;QACJ,CAAC;QACD,SAAS,CAAC,QAAQ,CAAC,KAAK,CAAC,iBAAiB,GAAG,gBAAgB,CAAC;QAC9D,IAAI,CAAC,KAAK,GAAG,gBAAgB,CAAC;IAChC,CAAC;IAED,MAAM,CAAC,SAAS;QACd,QAAQ,CAAC,GAAG,CAAC,uBAAuB,EAAE,KAAK,CAAC,CAAC;IAC/C,CAAC;IAEO,MAAM,CAAC,KAAK,CAAC,IAAI,CACvB,IAAe,EACf,IAAY,EACZ,MAAqB;QAErB,MAAM,GAAG,GAAG,IAAI,YAAY,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;QAC3C,MAAM,QAAQ,GAAG,QAAQ,CAAC,GAAG,CAAmB,uBAAuB,CAAC,CAAC;QAEzE,IAAI,CAAC,QAAQ,EAAE,CAAC;YACd,MAAM,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YACrB,QAAQ,CAAC,GAAG,CAAC,uBAAuB,EAAE,IAAI,CAAC,CAAC;QAC9C,CAAC;QAED,OAAO,GAAG,CAAC;IACb,CAAC;IAEO,MAAM;QACZ,OAAO,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;IACzC,CAAC;IAED,MAAM,CAAC,KAAK,CAAC,MAAM,CACjB,IAAe,EACf,IAAY,EACZ,MAAc;QAEd,MAAM,OAAO,GAAG,MAAM,YAAY,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,EAAE,MAAM,CAAC,CAAC;QAC5D,OAAO,OAAO,CAAC,MAAM,EAAE,CAAC;IAC1B,CAAC;IAEO,KAAK,CAAC,IAAQ;QACpB,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,IAAI,CAAC;IACvC,CAAC;IAED,MAAM,CAAC,KAAK,CAAC,KAAK,CAChB,IAAe,EACf,IAAY,EACZ,MAAc,EACd,IAAQ;QAER,MAAM,OAAO,GAAG,MAAM,YAAY,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,EAAE,MAAM,CAAC,CAAC;QAC5D,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;IACtB,CAAC;IAEO,SAAS,CAAC,QAAc;QAC9B,MAAM,EAAE,KAAK,EAAE,GAAG,IAAI,CAAC,KAAK,CAAC;QAC7B,IAAI,EAAE,UAAU,EAAE,GAAG,IAAI,CAAC,KAAK,CAAC;QAChC,MAAM,SAAS,GAAG,UAAU,CAAC,CAAC,CAAC,gBAAQ,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;QAEnE,IAAI,YAAY,GAAG,IAAI,CAAC;QAExB,KAAK,MAAM,OAAO,IAAI,QAAQ,EAAE,CAAC;YAC/B,MAAM,EAAE,GAAG,OAAO,CAAC,MAAM,CAAC;YAE1B,MAAM,OAAO,GAAG,IAAA,oBAAY,EAAC,OAAO,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;YACnD,IAAI,CAAC,OAAO,EAAE,CAAC;gBACb,SAAS;YACX,CAAC;YAED,MAAM,OAAO,GAAG,KAAK,CAAC,EAAE,CAAC,CAAC;YAC1B,IAAI,IAAA,eAAM,EAAC,OAAO,EAAE,OAAO,CAAC,EAAE,CAAC;gBAC7B,YAAY,GAAG,KAAK,CAAC;gBACrB,SAAS;YACX,CAAC;YAED,KAAK,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC;YAEpB,MAAM,QAAQ,GAAG,gBAAQ,CAAC,OAAO,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC;YACtD,IAAI,CAAC,SAAS,IAAI,QAAQ,GAAG,SAAS,EAAE,CAAC;gBACvC,UAAU,GAAG,OAAO,CAAC,UAAU,CAAC;YAClC,CAAC;QACH,CAAC;QAED,IAAI,CAAC,KAAK,CAAC,UAAU,GAAG,UAAU,CAAC;QAEnC,OAAO,YAAY,CAAC;IACtB,CAAC;IAEO,KAAK,CAAC,IAAI,CAAC,IAAe;QAChC,MAAM,KAAK,GAAG,IAAA,oBAAc,EAAC;YAC3B,KAAK,EAAE,KAAK;YACZ,IAAI,EAAE,cAAc;SACrB,CAAC,CAAC;QAEH,IAAI,GAAG,GACL,GAAG,gBAAQ,UAAU,IAAI,CAAC,IAAI,UAAU,KAAK,EAAE,CAAC;QAElD,OAAO,GAAG,EAAE,CAAC;YACX,MAAM,GAAG,GAAuB,MAAM,IAAI,CAAC,OAAO,CAAO,GAAG,EAAE;gBAC5D,QAAQ,EAAE,KAAK;gBACf,QAAQ,EAAE,KAAK;aAChB,CAAC,CAAC;YAEH,MAAM,YAAY,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;YAC9C,IAAI,CAAC,YAAY,EAAE,CAAC;gBAClB,MAAM;YACR,CAAC;YAED,GAAG,GAAG,IAAA,qBAAe,EAAC,GAAG,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE,GAAG,CAAC;QACrD,CAAC;QAED,OAAO,IAAI,CAAC;IACd,CAAC;CACF;AAlID,oCAkIC","sourcesContent":["import { dequal } from 'dequal';\nimport { DateTime } from 'luxon';\nimport * as memCache from '../../../util/cache/memory';\nimport { getCache } from '../../../util/cache/repository';\nimport type { GiteaHttp } from '../../../util/http/gitea';\nimport type { HttpResponse } from '../../../util/http/types';\nimport { getQueryString, parseLinkHeader } from '../../../util/url';\nimport type { Pr } from '../types';\nimport type { GiteaPrCacheData, PR } from './types';\nimport { API_PATH, toRenovatePR } from './utils';\n\nexport class GiteaPrCache {\n  private cache: GiteaPrCacheData;\n\n  private constructor(\n    private repo: string,\n    private author: string | null,\n  ) {\n    const repoCache = getCache();\n    repoCache.platform ??= {};\n    repoCache.platform.gitea ??= {};\n    let pullRequestCache = repoCache.platform.gitea.pullRequestsCache as\n      | GiteaPrCacheData\n      | undefined;\n    if (!pullRequestCache || pullRequestCache.author !== author) {\n      pullRequestCache = {\n        items: {},\n        updated_at: null,\n        author,\n      };\n    }\n    repoCache.platform.gitea.pullRequestsCache = pullRequestCache;\n    this.cache = pullRequestCache;\n  }\n\n  static forceSync(): void {\n    memCache.set('gitea-pr-cache-synced', false);\n  }\n\n  private static async init(\n    http: GiteaHttp,\n    repo: string,\n    author: string | null,\n  ): Promise<GiteaPrCache> {\n    const res = new GiteaPrCache(repo, author);\n    const isSynced = memCache.get<true | undefined>('gitea-pr-cache-synced');\n\n    if (!isSynced) {\n      await res.sync(http);\n      memCache.set('gitea-pr-cache-synced', true);\n    }\n\n    return res;\n  }\n\n  private getPrs(): Pr[] {\n    return Object.values(this.cache.items);\n  }\n\n  static async getPrs(\n    http: GiteaHttp,\n    repo: string,\n    author: string,\n  ): Promise<Pr[]> {\n    const prCache = await GiteaPrCache.init(http, repo, author);\n    return prCache.getPrs();\n  }\n\n  private addPr(item: Pr): void {\n    this.cache.items[item.number] = item;\n  }\n\n  static async addPr(\n    http: GiteaHttp,\n    repo: string,\n    author: string,\n    item: Pr,\n  ): Promise<void> {\n    const prCache = await GiteaPrCache.init(http, repo, author);\n    prCache.addPr(item);\n  }\n\n  private reconcile(rawItems: PR[]): boolean {\n    const { items } = this.cache;\n    let { updated_at } = this.cache;\n    const cacheTime = updated_at ? DateTime.fromISO(updated_at) : null;\n\n    let needNextPage = true;\n\n    for (const rawItem of rawItems) {\n      const id = rawItem.number;\n\n      const newItem = toRenovatePR(rawItem, this.author);\n      if (!newItem) {\n        continue;\n      }\n\n      const oldItem = items[id];\n      if (dequal(oldItem, newItem)) {\n        needNextPage = false;\n        continue;\n      }\n\n      items[id] = newItem;\n\n      const itemTime = DateTime.fromISO(rawItem.updated_at);\n      if (!cacheTime || itemTime > cacheTime) {\n        updated_at = rawItem.updated_at;\n      }\n    }\n\n    this.cache.updated_at = updated_at;\n\n    return needNextPage;\n  }\n\n  private async sync(http: GiteaHttp): Promise<GiteaPrCache> {\n    const query = getQueryString({\n      state: 'all',\n      sort: 'recentupdate',\n    });\n\n    let url: string | undefined =\n      `${API_PATH}/repos/${this.repo}/pulls?${query}`;\n\n    while (url) {\n      const res: HttpResponse<PR[]> = await http.getJson<PR[]>(url, {\n        memCache: false,\n        paginate: false,\n      });\n\n      const needNextPage = this.reconcile(res.body);\n      if (!needNextPage) {\n        break;\n      }\n\n      url = parseLinkHeader(res.headers.link)?.next?.url;\n    }\n\n    return this;\n  }\n}\n"]}