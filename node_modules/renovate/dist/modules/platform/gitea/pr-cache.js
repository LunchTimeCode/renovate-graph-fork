"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GiteaPrCache = void 0;
const tslib_1 = require("tslib");
const dequal_1 = require("dequal");
const luxon_1 = require("luxon");
const memCache = tslib_1.__importStar(require("../../../util/cache/memory"));
const repository_1 = require("../../../util/cache/repository");
const url_1 = require("../../../util/url");
const utils_1 = require("./utils");
class GiteaPrCache {
    repo;
    author;
    cache;
    constructor(repo, author) {
        this.repo = repo;
        this.author = author;
        const repoCache = (0, repository_1.getCache)();
        repoCache.platform ??= {};
        repoCache.platform.gitea ??= {};
        let pullRequestCache = repoCache.platform.gitea.pullRequestsCache;
        if (!pullRequestCache || pullRequestCache.author !== author) {
            pullRequestCache = {
                items: {},
                updated_at: null,
                author,
            };
        }
        repoCache.platform.gitea.pullRequestsCache = pullRequestCache;
        this.cache = pullRequestCache;
    }
    static forceSync() {
        memCache.set('gitea-pr-cache-synced', false);
    }
    static async init(http, repo, author) {
        const res = new GiteaPrCache(repo, author);
        const isSynced = memCache.get('gitea-pr-cache-synced');
        if (!isSynced) {
            await res.sync(http);
            memCache.set('gitea-pr-cache-synced', true);
        }
        return res;
    }
    getPrs() {
        return Object.values(this.cache.items);
    }
    static async getPrs(http, repo, author) {
        const prCache = await GiteaPrCache.init(http, repo, author);
        return prCache.getPrs();
    }
    addPr(item) {
        this.cache.items[item.number] = item;
    }
    static async addPr(http, repo, author, item) {
        const prCache = await GiteaPrCache.init(http, repo, author);
        prCache.addPr(item);
    }
    reconcile(rawItems) {
        const { items } = this.cache;
        let { updated_at } = this.cache;
        const cacheTime = updated_at ? luxon_1.DateTime.fromISO(updated_at) : null;
        let needNextPage = true;
        for (const rawItem of rawItems) {
            const id = rawItem.number;
            const newItem = (0, utils_1.toRenovatePR)(rawItem, this.author);
            if (!newItem) {
                continue;
            }
            const oldItem = items[id];
            if ((0, dequal_1.dequal)(oldItem, newItem)) {
                needNextPage = false;
                continue;
            }
            items[id] = newItem;
            const itemTime = luxon_1.DateTime.fromISO(rawItem.updated_at);
            if (!cacheTime || itemTime > cacheTime) {
                updated_at = rawItem.updated_at;
            }
        }
        this.cache.updated_at = updated_at;
        return needNextPage;
    }
    async sync(http) {
        const query = (0, url_1.getQueryString)({
            state: 'all',
            sort: 'recentupdate',
        });
        let url = `${utils_1.API_PATH}/repos/${this.repo}/pulls?${query}`;
        while (url) {
            const res = await http.getJson(url, {
                memCache: false,
                paginate: false,
            });
            const needNextPage = this.reconcile(res.body);
            if (!needNextPage) {
                break;
            }
            url = (0, url_1.parseLinkHeader)(res.headers.link)?.next?.url;
        }
        return this;
    }
}
exports.GiteaPrCache = GiteaPrCache;
//# sourceMappingURL=pr-cache.js.map