"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractPackageFile = void 0;
const tslib_1 = require("tslib");
const is_1 = tslib_1.__importDefault(require("@sindresorhus/is"));
const logger_1 = require("../../../logger");
const array_1 = require("../../../util/array");
const url_1 = require("../../../util/url");
const yaml_1 = require("../../../util/yaml");
const docker_1 = require("../../datasource/docker");
const git_tags_1 = require("../../datasource/git-tags");
const helm_1 = require("../../datasource/helm");
const oci_1 = require("../helmv3/oci");
const schema_1 = require("./schema");
const util_1 = require("./util");
function extractPackageFile(content, packageFile, _config) {
    // check for argo reference. API version for the kind attribute is used
    if (util_1.fileTestRegex.test(content) === false) {
        logger_1.logger.debug(`Skip file ${packageFile} as no argoproj.io apiVersion could be found in matched file`);
        return null;
    }
    let definitions;
    try {
        definitions = (0, yaml_1.parseYaml)(content, null, {
            customSchema: schema_1.ApplicationDefinition,
            failureBehaviour: 'filter',
            removeTemplates: true,
        });
    }
    catch (err) {
        logger_1.logger.debug({ err, packageFile }, 'Failed to parse ArgoCD definition.');
        return null;
    }
    const deps = definitions.flatMap(processAppSpec);
    return deps.length ? { deps } : null;
}
exports.extractPackageFile = extractPackageFile;
function processSource(source) {
    // a chart variable is defined this is helm declaration
    if (source.chart) {
        // assume OCI helm chart if repoURL doesn't contain explicit protocol
        if ((0, oci_1.isOCIRegistry)(source.repoURL) || !source.repoURL.includes('://')) {
            const registryURL = (0, url_1.trimTrailingSlash)((0, oci_1.removeOCIPrefix)(source.repoURL));
            return {
                depName: `${registryURL}/${source.chart}`,
                currentValue: source.targetRevision,
                datasource: docker_1.DockerDatasource.id,
            };
        }
        return {
            depName: source.chart,
            registryUrls: [source.repoURL],
            currentValue: source.targetRevision,
            datasource: helm_1.HelmDatasource.id,
        };
    }
    return {
        depName: source.repoURL,
        currentValue: source.targetRevision,
        datasource: git_tags_1.GitTagsDatasource.id,
    };
}
function processAppSpec(definition) {
    const spec = definition.kind === 'Application'
        ? definition.spec
        : definition.spec.template.spec;
    const deps = [];
    if (is_1.default.nonEmptyObject(spec.source)) {
        deps.push(processSource(spec.source));
    }
    for (const source of (0, array_1.coerceArray)(spec.sources)) {
        deps.push(processSource(source));
    }
    return deps.filter(is_1.default.truthy);
}
//# sourceMappingURL=extract.js.map