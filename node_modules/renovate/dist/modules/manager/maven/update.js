"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.bumpPackageVersion = exports.updateDependency = exports.updateAtPosition = void 0;
const tslib_1 = require("tslib");
const is_1 = tslib_1.__importDefault(require("@sindresorhus/is"));
const semver_1 = tslib_1.__importDefault(require("semver"));
const xmldoc_1 = require("xmldoc");
const logger_1 = require("../../../logger");
const string_1 = require("../../../util/string");
function updateAtPosition(fileContent, upgrade, endingAnchor) {
    const { depName, currentValue, newValue, fileReplacePosition } = upgrade;
    const leftPart = fileContent.slice(0, fileReplacePosition);
    const rightPart = fileContent.slice(fileReplacePosition);
    const versionClosePosition = rightPart.indexOf(endingAnchor);
    const restPart = rightPart.slice(versionClosePosition);
    const versionPart = rightPart.slice(0, versionClosePosition);
    const version = versionPart.trim();
    if (version === newValue) {
        return fileContent;
    }
    if (version === currentValue || upgrade.groupName) {
        // TODO: validate newValue (#22198)
        const replacedPart = versionPart.replace(version, newValue);
        return leftPart + replacedPart + restPart;
    }
    logger_1.logger.debug({ depName, version, currentValue, newValue }, 'Unknown value');
    return null;
}
exports.updateAtPosition = updateAtPosition;
function updateDependency({ fileContent, upgrade, }) {
    if (upgrade.updateType === 'replacement') {
        logger_1.logger.warn('maven manager does not support replacement updates yet');
        return null;
    }
    const offset = fileContent.indexOf('<');
    const spaces = fileContent.slice(0, offset);
    const restContent = fileContent.slice(offset);
    const updatedContent = updateAtPosition(restContent, upgrade, '</');
    if (!updatedContent) {
        return null;
    }
    if (updatedContent === restContent) {
        return fileContent;
    }
    return `${spaces}${updatedContent}`;
}
exports.updateDependency = updateDependency;
function bumpPackageVersion(content, currentValue, bumpVersion) {
    logger_1.logger.debug({ bumpVersion, currentValue }, 'Checking if we should bump pom.xml version');
    let bumpedContent = content;
    if (!semver_1.default.valid(currentValue)) {
        logger_1.logger.warn({ currentValue }, 'Unable to bump pom.xml version, not a valid semver');
        return { bumpedContent };
    }
    try {
        const project = new xmldoc_1.XmlDocument(content);
        const versionNode = project.childNamed('version');
        const startTagPosition = versionNode.startTagPosition;
        const versionPosition = content.indexOf(versionNode.val, startTagPosition);
        let newPomVersion = null;
        const currentPrereleaseValue = semver_1.default.prerelease(currentValue);
        if (isSnapshot(currentPrereleaseValue)) {
            // It is already a SNAPSHOT version.
            // Therefore the same qualifier (prerelease) will be used as before.
            let releaseType = bumpVersion;
            if (!bumpVersion.startsWith('pre')) {
                releaseType = `pre${bumpVersion}`;
            }
            newPomVersion = semver_1.default.inc(currentValue, releaseType, currentPrereleaseValue.join('.'), false);
        }
        else if (currentPrereleaseValue) {
            // Some qualifier which is not a SNAPSHOT is present.
            // The expected behaviour in this case is unclear and the standard increase will be used.
            newPomVersion = semver_1.default.inc(currentValue, bumpVersion);
        }
        else {
            // A release version without any qualifier is present.
            // Therefore the SNAPSHOT qualifier will be added if a prerelease is requested.
            // This will do a normal increment, ignoring SNAPSHOT, if a non-prerelease bumpVersion is configured
            newPomVersion = semver_1.default.inc(currentValue, bumpVersion, 'SNAPSHOT', false);
        }
        if (!newPomVersion) {
            throw new Error('semver inc failed');
        }
        logger_1.logger.debug({ newPomVersion });
        bumpedContent = (0, string_1.replaceAt)(content, versionPosition, currentValue, newPomVersion);
        if (bumpedContent === content) {
            logger_1.logger.debug('Version was already bumped');
        }
        else {
            logger_1.logger.debug('pom.xml version bumped');
        }
    }
    catch (err) {
        logger_1.logger.warn({
            content,
            currentValue,
            bumpVersion,
        }, 'Failed to bumpVersion');
    }
    return { bumpedContent };
}
exports.bumpPackageVersion = bumpPackageVersion;
function isSnapshot(prerelease) {
    const lastPart = prerelease?.at(-1);
    return is_1.default.string(lastPart) && lastPart.endsWith('SNAPSHOT');
}
//# sourceMappingURL=update.js.map