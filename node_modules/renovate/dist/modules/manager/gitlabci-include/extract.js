"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractPackageFile = void 0;
const tslib_1 = require("tslib");
const is_1 = tslib_1.__importDefault(require("@sindresorhus/is"));
const global_1 = require("../../../config/global");
const logger_1 = require("../../../logger");
const regex_1 = require("../../../util/regex");
const yaml_1 = require("../../../util/yaml");
const gitlab_tags_1 = require("../../datasource/gitlab-tags");
const common_1 = require("../gitlabci/common");
const utils_1 = require("../gitlabci/utils");
function extractDepFromIncludeFile(includeObj) {
    const dep = {
        datasource: gitlab_tags_1.GitlabTagsDatasource.id,
        depName: includeObj.project,
        depType: 'repository',
    };
    if (!includeObj.ref) {
        dep.skipReason = 'unspecified-version';
        return dep;
    }
    dep.currentValue = includeObj.ref;
    return dep;
}
function getIncludeProjectsFromInclude(includeValue) {
    const includes = is_1.default.array(includeValue) ? includeValue : [includeValue];
    // Filter out includes that dont have a file & project.
    return includes.filter(common_1.isGitlabIncludeProject);
}
function getAllIncludeProjects(data) {
    // If Array, search each element.
    if (is_1.default.array(data)) {
        return data
            .filter(common_1.isNonEmptyObject)
            .map(getAllIncludeProjects)
            .flat();
    }
    const childrenData = Object.values((0, common_1.filterIncludeFromGitlabPipeline)(data))
        .filter(common_1.isNonEmptyObject)
        .map(getAllIncludeProjects)
        .flat();
    // Process include key.
    if (data.include) {
        childrenData.push(...getIncludeProjectsFromInclude(data.include));
    }
    return childrenData;
}
function extractPackageFile(content, packageFile) {
    const deps = [];
    const platform = global_1.GlobalConfig.get('platform');
    const endpoint = global_1.GlobalConfig.get('endpoint');
    try {
        // TODO: use schema (#9610)
        const doc = (0, yaml_1.parseSingleYaml)((0, utils_1.replaceReferenceTags)(content), {
            json: true,
        });
        const includes = getAllIncludeProjects(doc);
        for (const includeObj of includes) {
            const dep = extractDepFromIncludeFile(includeObj);
            if (platform === 'gitlab' && endpoint) {
                dep.registryUrls = [endpoint.replace((0, regex_1.regEx)(/\/api\/v4\/?/), '')];
            }
            deps.push(dep);
        }
    }
    catch (err) /* istanbul ignore next */ {
        if (err.stack?.startsWith('YAMLException:')) {
            logger_1.logger.debug({ err, packageFile }, 'YAML exception extracting GitLab CI includes');
        }
        else {
            logger_1.logger.debug({ err, packageFile }, 'Error extracting GitLab CI includes');
        }
    }
    if (!deps.length) {
        return null;
    }
    return { deps };
}
exports.extractPackageFile = extractPackageFile;
//# sourceMappingURL=extract.js.map