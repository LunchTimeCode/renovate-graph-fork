"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleRecursive = exports.handleCombination = exports.handleAny = void 0;
const tslib_1 = require("tslib");
const is_1 = tslib_1.__importDefault(require("@sindresorhus/is"));
const logger_1 = require("../../../../logger");
const regex_1 = require("../../../../util/regex");
const utils_1 = require("./utils");
function handleAny(content, packageFile, config) {
    return config.matchStrings
        .map((matchString) => (0, regex_1.regEx)(matchString, 'g'))
        .flatMap((regex) => (0, utils_1.regexMatchAll)(regex, content)) // match all regex to content, get all matches, reduce to single array
        .map((matchResult) => (0, utils_1.createDependency)({
        groups: matchResult.groups ??
            /* istanbul ignore next: can this happen? */ {},
        replaceString: matchResult[0],
    }, config))
        .filter(is_1.default.truthy)
        .filter((dep) => checkIsValidDependency(dep, packageFile));
}
exports.handleAny = handleAny;
function handleCombination(content, packageFile, config) {
    const matches = config.matchStrings
        .map((matchString) => (0, regex_1.regEx)(matchString, 'g'))
        .flatMap((regex) => (0, utils_1.regexMatchAll)(regex, content)); // match all regex to content, get all matches, reduce to single array
    if (!matches.length) {
        return [];
    }
    const extraction = matches
        .map((match) => ({
        groups: match.groups ?? /* istanbul ignore next: can this happen? */ {},
        replaceString: match?.groups?.currentValue ?? match?.groups?.currentDigest
            ? match[0]
            : undefined,
    }))
        .reduce((base, addition) => (0, utils_1.mergeExtractionTemplate)(base, addition));
    return [(0, utils_1.createDependency)(extraction, config)]
        .filter(is_1.default.truthy)
        .filter((dep) => checkIsValidDependency(dep, packageFile));
}
exports.handleCombination = handleCombination;
function handleRecursive(content, packageFile, config) {
    const regexes = config.matchStrings.map((matchString) => (0, regex_1.regEx)(matchString, 'g'));
    return processRecursive({
        content,
        packageFile,
        config,
        index: 0,
        combinedGroups: {},
        regexes,
    })
        .filter(is_1.default.truthy)
        .filter((dep) => checkIsValidDependency(dep, packageFile));
}
exports.handleRecursive = handleRecursive;
function processRecursive(parameters) {
    const { content, index, combinedGroups, regexes, config, } = parameters;
    // abort if we have no matchString anymore
    if (regexes.length === index) {
        const result = (0, utils_1.createDependency)({
            groups: combinedGroups,
            replaceString: content,
        }, config);
        return result ? [result] : /* istanbul ignore next: can this happen? */ [];
    }
    return (0, utils_1.regexMatchAll)(regexes[index], content).flatMap((match) => {
        return processRecursive({
            ...parameters,
            content: match[0],
            index: index + 1,
            combinedGroups: (0, utils_1.mergeGroups)(combinedGroups, match.groups ?? {}),
        });
    });
}
function checkIsValidDependency(dep, packageFile) {
    const isValid = (0, utils_1.isValidDependency)(dep);
    if (!isValid) {
        const meta = {
            packageDependency: dep,
            packageFile,
        };
        logger_1.logger.trace(meta, 'Discovered a package dependency by matching regex, but it did not pass validation. Discarding');
        return isValid;
    }
    return isValid;
}
//# sourceMappingURL=strategies.js.map