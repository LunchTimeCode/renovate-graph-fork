"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Unity3dDatasource = void 0;
const tslib_1 = require("tslib");
const xmldoc_1 = require("xmldoc");
const logger_1 = require("../../../logger");
const decorator_1 = require("../../../util/cache/package/decorator");
const Unity3dVersioning = tslib_1.__importStar(require("../../versioning/unity3d"));
const datasource_1 = require("../datasource");
class Unity3dDatasource extends datasource_1.Datasource {
    static homepage = 'https://unity.com/';
    static streams = {
        lts: `${Unity3dDatasource.homepage}releases/editor/lts-releases.xml`,
        stable: `${Unity3dDatasource.homepage}releases/editor/releases.xml`,
        beta: `${Unity3dDatasource.homepage}releases/editor/beta/latest.xml`,
    };
    static id = 'unity3d';
    defaultRegistryUrls = [
        Unity3dDatasource.streams.stable,
        Unity3dDatasource.streams.lts,
    ];
    defaultVersioning = Unity3dVersioning.id;
    registryStrategy = 'merge';
    releaseTimestampSupport = true;
    releaseTimestampNote = 'The release timestamp is determined from the `pubDate` tag in the results.';
    constructor() {
        super(Unity3dDatasource.id);
    }
    async getByStream(registryUrl, withHash) {
        let channel = undefined;
        try {
            const response = await this.http.get(registryUrl);
            const document = new xmldoc_1.XmlDocument(response.body);
            channel = document.childNamed('channel');
        }
        catch (err) {
            logger_1.logger.error({ err, registryUrl }, 'Failed to request releases from Unity3d datasource');
            return null;
        }
        if (!channel) {
            return {
                releases: [],
                homepage: Unity3dDatasource.homepage,
                registryUrl,
            };
        }
        const releases = channel
            .childrenNamed('item')
            .map((itemNode) => {
            const versionWithHash = `${itemNode.childNamed('title')?.val} (${itemNode.childNamed('guid')?.val})`;
            const versionWithoutHash = itemNode.childNamed('title')?.val;
            const release = {
                version: withHash ? versionWithHash : versionWithoutHash,
                releaseTimestamp: itemNode.childNamed('pubDate')?.val,
                changelogUrl: itemNode.childNamed('link')?.val,
                isStable: registryUrl !== Unity3dDatasource.streams.beta,
                registryUrl,
            };
            return release;
        })
            .filter((release) => !!release);
        return {
            releases,
            homepage: Unity3dDatasource.homepage,
            registryUrl,
        };
    }
    async getReleases({ packageName, registryUrl, }) {
        return await this.getByStream(registryUrl, packageName === 'm_EditorVersionWithRevision');
    }
}
exports.Unity3dDatasource = Unity3dDatasource;
tslib_1.__decorate([
    (0, decorator_1.cache)({
        namespace: `datasource-${Unity3dDatasource.id}`,
        key: ({ registryUrl, packageName }) => `${registryUrl}:${packageName}`,
    })
], Unity3dDatasource.prototype, "getReleases", null);
//# sourceMappingURL=index.js.map