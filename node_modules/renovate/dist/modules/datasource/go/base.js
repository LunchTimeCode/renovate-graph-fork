"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseGoDatasource = void 0;
const tslib_1 = require("tslib");
// TODO: types (#22198)
const node_url_1 = tslib_1.__importDefault(require("node:url"));
const global_1 = require("../../../config/global");
const logger_1 = require("../../../logger");
const common_1 = require("../../../util/common");
const hostRules = tslib_1.__importStar(require("../../../util/host-rules"));
const http_1 = require("../../../util/http");
const regex_1 = require("../../../util/regex");
const url_1 = require("../../../util/url");
const bitbucket_tags_1 = require("../bitbucket-tags");
const git_tags_1 = require("../git-tags");
const github_tags_1 = require("../github-tags");
const gitlab_tags_1 = require("../gitlab-tags");
// TODO: figure out class hierarchy (#10532)
class BaseGoDatasource {
    static gitlabHttpsRegExp = (0, regex_1.regEx)(/^(?<httpsRegExpUrl>https:\/\/[^/]*gitlab\.[^/]*)\/(?<httpsRegExpName>.+?)(?:\/v\d+)?[/]?$/);
    static gitlabRegExp = (0, regex_1.regEx)(/^(?<regExpUrl>gitlab\.[^/]*)\/(?<regExpPath>.+?)(?:\/v\d+)?[/]?$/);
    static gitVcsRegexp = (0, regex_1.regEx)(/^(?:[^/]+)\/(?<module>.*)\.git(?:$|\/)/);
    static id = 'go';
    static http = new http_1.Http(BaseGoDatasource.id);
    static async getDatasource(goModule) {
        if (goModule.startsWith('gopkg.in/')) {
            const [pkg] = goModule.replace('gopkg.in/', '').split('.');
            const packageName = pkg.includes('/') ? pkg : `go-${pkg}/${pkg}`;
            return {
                datasource: github_tags_1.GithubTagsDatasource.id,
                packageName,
                registryUrl: 'https://github.com',
            };
        }
        if (goModule.startsWith('github.com/')) {
            const split = goModule.split('/');
            const packageName = split[1] + '/' + split[2];
            return {
                datasource: github_tags_1.GithubTagsDatasource.id,
                packageName,
                registryUrl: 'https://github.com',
            };
        }
        if (goModule.startsWith('bitbucket.org/')) {
            const split = goModule.split('/');
            const packageName = split[1] + '/' + split[2];
            return {
                datasource: bitbucket_tags_1.BitbucketTagsDatasource.id,
                packageName,
                registryUrl: 'https://bitbucket.org',
            };
        }
        if (goModule.startsWith('code.cloudfoundry.org/')) {
            const packageName = goModule.replace('code.cloudfoundry.org', 'cloudfoundry');
            return {
                datasource: github_tags_1.GithubTagsDatasource.id,
                packageName,
                registryUrl: 'https://github.com',
            };
        }
        if (goModule.startsWith('dev.azure.com/')) {
            const split = goModule.split('/');
            if ((split.length > 4 && split[3] === '_git') || split.length > 3) {
                const packageName = 'https://dev.azure.com/' +
                    split[1] +
                    '/' +
                    split[2] +
                    '/_git/' +
                    (split[3] === '_git' ? split[4] : split[3]).replace((0, regex_1.regEx)(/\.git$/), '');
                return {
                    datasource: git_tags_1.GitTagsDatasource.id,
                    packageName,
                };
            }
        }
        return await BaseGoDatasource.goGetDatasource(goModule);
    }
    static async goGetDatasource(goModule) {
        const goModuleUrl = goModule.replace(/\.git\/v2$/, '');
        const pkgUrl = `https://${goModuleUrl}?go-get=1`;
        // GitHub Enterprise only returns a go-import meta
        const res = (await BaseGoDatasource.http.get(pkgUrl)).body;
        return (BaseGoDatasource.goSourceHeader(res, goModule) ??
            BaseGoDatasource.goImportHeader(res, goModule));
    }
    static goSourceHeader(res, goModule) {
        const sourceMatch = (0, regex_1.regEx)(`<meta\\s+name="?go-source"?\\s+content="([^\\s]+)\\s+([^\\s]+)`).exec(res);
        if (!sourceMatch) {
            return null;
        }
        const [, prefix, goSourceUrl] = sourceMatch;
        if (!goModule.startsWith(prefix)) {
            logger_1.logger.trace({ goModule }, 'go-source header prefix not match');
            return null;
        }
        logger_1.logger.debug(`Go lookup source url ${goSourceUrl} for module ${goModule}`);
        return this.detectDatasource(goSourceUrl, goModule);
    }
    static detectDatasource(goSourceUrl, goModule) {
        if (goSourceUrl?.startsWith('https://github.com/')) {
            return {
                datasource: github_tags_1.GithubTagsDatasource.id,
                packageName: goSourceUrl
                    .replace('https://github.com/', '')
                    .replace((0, regex_1.regEx)(/\/$/), ''),
                registryUrl: 'https://github.com',
            };
        }
        const gitlabUrl = BaseGoDatasource.gitlabHttpsRegExp.exec(goSourceUrl)?.groups
            ?.httpsRegExpUrl;
        const gitlabUrlName = BaseGoDatasource.gitlabHttpsRegExp.exec(goSourceUrl)?.groups
            ?.httpsRegExpName;
        const gitlabModuleName = BaseGoDatasource.gitlabRegExp.exec(goModule)?.groups?.regExpPath;
        if (gitlabUrl && gitlabUrlName) {
            if (gitlabModuleName?.startsWith(gitlabUrlName)) {
                const vcsIndicatedModule = BaseGoDatasource.gitVcsRegexp.exec(goModule);
                if (vcsIndicatedModule?.groups?.module) {
                    return {
                        datasource: gitlab_tags_1.GitlabTagsDatasource.id,
                        registryUrl: gitlabUrl,
                        packageName: vcsIndicatedModule.groups?.module,
                    };
                }
                return {
                    datasource: gitlab_tags_1.GitlabTagsDatasource.id,
                    registryUrl: gitlabUrl,
                    packageName: gitlabModuleName,
                };
            }
            return {
                datasource: gitlab_tags_1.GitlabTagsDatasource.id,
                registryUrl: gitlabUrl,
                packageName: gitlabUrlName,
            };
        }
        if (hostRules.hostType({ url: goSourceUrl }) === 'gitlab') {
            // get server base url from import url
            const parsedUrl = node_url_1.default.parse(goSourceUrl);
            // TODO: `parsedUrl.pathname` can be undefined
            let packageName = (0, url_1.trimLeadingSlash)(`${parsedUrl.pathname}`);
            const endpoint = global_1.GlobalConfig.get('endpoint');
            const endpointPrefix = (0, regex_1.regEx)('https://[^/]*/(.*?/)(api/v4/?)?').exec(endpoint);
            if (endpointPrefix && endpointPrefix[1] !== 'api/') {
                packageName = packageName.replace(endpointPrefix[1], '');
            }
            const registryUrl = endpointPrefix
                ? endpoint.replace((0, regex_1.regEx)('api/v4/?$'), '')
                : `${parsedUrl.protocol}//${parsedUrl.host}`;
            // a .git path indicates a concrete git repository, which can be different from metadata returned by gitlab
            const vcsIndicatedModule = BaseGoDatasource.gitVcsRegexp.exec(goModule);
            if (vcsIndicatedModule?.groups?.module) {
                if (endpointPrefix) {
                    packageName = vcsIndicatedModule.groups?.module.replace(endpointPrefix[1], '');
                }
                else {
                    packageName = vcsIndicatedModule.groups?.module;
                }
                return {
                    datasource: gitlab_tags_1.GitlabTagsDatasource.id,
                    registryUrl,
                    packageName,
                };
            }
            return {
                datasource: gitlab_tags_1.GitlabTagsDatasource.id,
                registryUrl,
                packageName,
            };
        }
        /* istanbul ignore next */
        return null;
    }
    static goImportHeader(res, goModule) {
        const importMatch = (0, regex_1.regEx)(`<meta\\s+name="?go-import"?\\s+content="([^\\s]+)\\s+([^\\s]+)\\s+([^\\s]+)"\\s*\\/?>`).exec(res);
        if (!importMatch) {
            logger_1.logger.trace({ goModule }, 'No go-source or go-import header found');
            return null;
        }
        const [, prefix, proto, goImportURL] = importMatch;
        if (!goModule.startsWith(prefix)) {
            logger_1.logger.trace({ goModule }, 'go-import header prefix not match');
            return null;
        }
        if (proto !== 'git') {
            logger_1.logger.trace({ goModule }, 'go-import header proto not git');
            return null;
        }
        logger_1.logger.debug(`Go module: ${goModule} lookup import url ${goImportURL}`);
        // get server base url from import url
        const parsedUrl = node_url_1.default.parse(goImportURL);
        const datasource = this.detectDatasource(goImportURL.replace((0, regex_1.regEx)(/\.git$/), ''), goModule);
        if (datasource !== null) {
            return datasource;
        }
        // fall back to old behavior if detection did not work
        switch ((0, common_1.detectPlatform)(goImportURL)) {
            case 'github': {
                // split the go module from the URL: host/go/module -> go/module
                // TODO: `parsedUrl.pathname` can be undefined
                const packageName = (0, url_1.trimTrailingSlash)(`${parsedUrl.pathname}`)
                    .replace((0, regex_1.regEx)(/\.git$/), '')
                    .split('/')
                    .slice(-2)
                    .join('/');
                return {
                    datasource: github_tags_1.GithubTagsDatasource.id,
                    registryUrl: `${parsedUrl.protocol}//${parsedUrl.host}`,
                    packageName,
                };
            }
            case 'azure': {
                return {
                    datasource: git_tags_1.GitTagsDatasource.id,
                    packageName: goImportURL.replace((0, regex_1.regEx)(/\.git$/), ''),
                };
            }
            default: {
                return {
                    datasource: git_tags_1.GitTagsDatasource.id,
                    packageName: goImportURL,
                };
            }
        }
    }
}
exports.BaseGoDatasource = BaseGoDatasource;
//# sourceMappingURL=base.js.map