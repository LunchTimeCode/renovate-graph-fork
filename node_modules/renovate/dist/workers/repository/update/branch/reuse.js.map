{"version":3,"file":"reuse.js","sourceRoot":"","sources":["../../../../../lib/workers/repository/update/branch/reuse.ts"],"names":[],"mappings":"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","sourcesContent":["import { logger } from '../../../../logger';\nimport { platform } from '../../../../modules/platform';\nimport { scm } from '../../../../modules/platform/scm';\nimport type { RangeStrategy } from '../../../../types';\nimport type { BranchConfig } from '../../../types';\n\ntype ParentBranch = {\n  reuseExistingBranch: boolean;\n  isModified?: boolean;\n  isConflicted?: boolean;\n};\n\nasync function shouldKeepUpdated(\n  config: BranchConfig,\n  baseBranch: string,\n  branchName: string,\n): Promise<boolean> {\n  const keepUpdatedLabel = config.keepUpdatedLabel;\n  if (!keepUpdatedLabel) {\n    return false;\n  }\n\n  const branchPr = await platform.getBranchPr(\n    config.branchName,\n    config.baseBranch,\n  );\n\n  if (branchPr?.labels?.includes(keepUpdatedLabel)) {\n    return true;\n  }\n\n  return false;\n}\n\nexport async function shouldReuseExistingBranch(\n  config: BranchConfig,\n): Promise<ParentBranch> {\n  const { baseBranch, branchName } = config;\n  const result: ParentBranch = { reuseExistingBranch: false };\n  // Check if branch exists\n  if (!(await scm.branchExists(branchName))) {\n    logger.debug(`Branch needs creating`);\n    return result;\n  }\n  logger.debug(`Branch already exists`);\n  if (\n    config.rebaseWhen === 'behind-base-branch' ||\n    (await shouldKeepUpdated(config, baseBranch, branchName)) ||\n    (config.rebaseWhen === 'auto' &&\n      (config.automerge === true ||\n        (await platform.getBranchForceRebase?.(config.baseBranch))))\n  ) {\n    if (await scm.isBranchBehindBase(branchName, baseBranch)) {\n      logger.debug(`Branch is behind base branch and needs rebasing`);\n      // We can rebase the branch only if no PR or PR can be rebased\n      if (await scm.isBranchModified(branchName)) {\n        logger.debug('Cannot rebase branch as it has been modified');\n        result.reuseExistingBranch = true;\n        result.isModified = true;\n        return result;\n      }\n      logger.debug('Branch is unmodified, so can be rebased');\n      return result;\n    }\n    logger.debug('Branch is up-to-date');\n  } else {\n    logger.debug(\n      `Skipping behind base branch check due to rebaseWhen=${config.rebaseWhen!}`,\n    );\n  }\n\n  // Now check if PR is unmergeable. If so then we also rebase\n  result.isConflicted = await scm.isBranchConflicted(baseBranch, branchName);\n  if (result.isConflicted) {\n    logger.debug('Branch is conflicted');\n\n    if ((await scm.isBranchModified(branchName)) === false) {\n      logger.debug(`Branch is not mergeable and needs rebasing`);\n      if (\n        config.rebaseWhen === 'never' &&\n        !(await shouldKeepUpdated(config, baseBranch, branchName))\n      ) {\n        logger.debug('Rebasing disabled by config');\n        result.reuseExistingBranch = true;\n        result.isModified = false;\n      }\n      // Setting reuseExistingBranch back to undefined means that we'll use the default branch\n      return result;\n    }\n    // Don't do anything different, but warn\n    // TODO: Add warning to PR (#9720)\n    logger.debug(`Branch is not mergeable but can't be rebased`);\n  }\n  logger.debug(`Branch does not need rebasing`);\n\n  // Branches can get in an inconsistent state if \"update-lockfile\" is used at the same time as other strategies\n  // On the first execution, everything is executed, but if on a second execution the package.json modification is\n  // skipped but the lockfile update is executed, the lockfile will have a different result than if it was executed\n  // along with the changes to the package.json. Thus ending up with an incomplete branch update\n  // This is why we are skipping branch reuse in this case (#10050)\n  const groupedByPackageFile: Record<string, Set<RangeStrategy>> = {};\n  for (const upgrade of config.upgrades) {\n    const packageFile = upgrade.packageFile!;\n    groupedByPackageFile[packageFile] ??= new Set();\n    groupedByPackageFile[packageFile].add(upgrade.rangeStrategy!);\n\n    if (\n      groupedByPackageFile[packageFile].size > 1 &&\n      groupedByPackageFile[packageFile].has('update-lockfile')\n    ) {\n      logger.debug(\n        `Detected multiple rangeStrategies along with update-lockfile`,\n      );\n      result.reuseExistingBranch = false;\n      result.isModified = false;\n      return result;\n    }\n  }\n\n  result.reuseExistingBranch = true;\n  result.isModified = false;\n  return result;\n}\n"]}