{"version":3,"file":"get-updated.js","sourceRoot":"","sources":["../../../../../lib/workers/repository/update/branch/get-updated.ts"],"names":[],"mappings":";;;;AAAA,qEAAqE;AACrE,kEAAkC;AAClC,yEAAiF;AACjF,+CAA4C;AAC5C,yDAAkD;AASlD,8CAA+C;AAE/C,oDAAuD;AAEvD,iDAA+C;AAU/C,KAAK,UAAU,cAAc,CAC3B,mBAA2C,EAC3C,QAAgB,EAChB,MAAoB;IAEpB,IAAI,WAAW,GAAkB,mBAAmB,CAAC,QAAQ,CAAC,CAAC;IAC/D,IAAI,CAAC,WAAW,EAAE,CAAC;QACjB,WAAW,GAAG,MAAM,IAAA,aAAO,EACzB,QAAQ,EACR,MAAM,CAAC,mBAAmB,CAAC,CAAC,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC,CAAC,MAAM,CAAC,UAAU,CACnE,CAAC;IACJ,CAAC;IACD,OAAO,WAAW,CAAC;AACrB,CAAC;AAEM,KAAK,UAAU,sBAAsB,CAC1C,MAAoB;IAEpB,eAAM,CAAC,KAAK,CAAC,EAAE,MAAM,EAAE,CAAC,CAAC;IACzB,MAAM,mBAAmB,GAAG,MAAM,CAAC,mBAAoB,CAAC;IACxD,eAAM,CAAC,KAAK,CACV,wDAAwD,mBAAmB,EAAE,CAC9E,CAAC;IACF,IAAI,mBAAmB,GAA2B,EAAE,CAAC;IACrD,MAAM,sBAAsB,GAA2B,EAAE,CAAC;IAC1D,MAAM,mBAAmB,GAAgC,EAAE,CAAC;IAC5D,MAAM,sBAAsB,GAAwC,EAAE,CAAC;IACvE,MAAM,wBAAwB,GAAG,EAAE,CAAC;IACpC,IAAI,WAAW,GAAG,IAAI,CAAC;IACvB,KAAK,MAAM,OAAO,IAAI,MAAM,CAAC,QAAQ,EAAE,CAAC;QACtC,MAAM,OAAO,GAAG,OAAO,CAAC,OAAQ,CAAC;QACjC,MAAM,WAAW,GAAG,OAAO,CAAC,WAAY,CAAC;QACzC,MAAM,OAAO,GAAG,OAAO,CAAC,OAAQ,CAAC;QACjC,6CAA6C;QAC7C,MAAM,UAAU,GAAG,OAAO,CAAC,UAAW,CAAC;QACvC,MAAM,cAAc,GAAG,OAAO,CAAC,cAAe,CAAC;QAC/C,MAAM,sBAAsB,GAAG,IAAA,aAAG,EAAC,OAAO,EAAE,wBAAwB,CAAE,CAAC;QACvE,mBAAmB,CAAC,WAAW,CAAC,KAAK,IAAI,GAAG,EAAU,CAAC;QACvD,mBAAmB,CAAC,WAAW,CAAC,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;QAC9C,sBAAsB,CAAC,WAAW,CAAC,KAAK,EAAE,CAAC;QAC3C,sBAAsB,CAAC,WAAW,CAAC,CAAC,IAAI,CAAC,EAAE,GAAG,OAAO,EAAE,CAAC,CAAC;QACzD,MAAM,kBAAkB,GAAG,MAAM,cAAc,CAC7C,mBAAmB,EACnB,WAAW,EACX,MAAM,CACP,CAAC;QACF,IAAI,eAAe,GAAkB,IAAI,CAAC;QAC1C,MAAM,QAAQ,GAAG,OAAO,CAAC,QAAQ,IAAI,OAAO,CAAC,SAAS,EAAE,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC;QAClE,IAAI,QAAQ,EAAE,CAAC;YACb,eAAe,GAAG,MAAM,cAAc,CACpC,mBAAmB,EACnB,QAAQ,EACR,MAAM,CACP,CAAC;QACJ,CAAC;QACD,qBAAqB;QACrB,IACE,mBAAmB;YACnB,CAAC,CAAC,kBAAkB,IAAI,CAAC,QAAQ,IAAI,CAAC,eAAe,CAAC,CAAC,EACvD,CAAC;YACD,eAAM,CAAC,KAAK,CACV,EAAE,WAAW,EAAE,OAAO,EAAE,EACxB,sCAAsC,CACvC,CAAC;YACF,OAAO,sBAAsB,CAAC;gBAC5B,GAAG,MAAM;gBACT,mBAAmB,EAAE,KAAK;aAC3B,CAAC,CAAC;QACL,CAAC;QACD,IAAI,OAAO,CAAC,UAAU,KAAK,qBAAqB,EAAE,CAAC;YACjD,wBAAwB,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;QAC7C,CAAC;aAAM,IAAI,OAAO,CAAC,aAAa,EAAE,CAAC;YACjC,MAAM,EAAE,MAAM,EAAE,KAAK,EAAE,GAAG,MAAM,sBAAsB,CAAC;gBACrD,GAAG,OAAO;gBACV,OAAO;gBACP,UAAU;gBACV,cAAc;gBACd,WAAW;gBACX,kBAAkB,EAAE,kBAAmB;gBACvC,QAAQ;gBACR,eAAe,EAAE,eAAgB;gBACjC,kBAAkB,EAAE,IAAI;gBACxB,oBAAoB,EAAE,IAAI;aAC3B,CAAC,CAAC;YACH,IAAI,mBAAmB,IAAI,MAAM,KAAK,iBAAiB,EAAE,CAAC;gBACxD,eAAM,CAAC,KAAK,CACV,EAAE,QAAQ,EAAE,OAAO,EAAE,MAAM,EAAE,EAC7B,sDAAsD,CACvD,CAAC;gBACF,OAAO,sBAAsB,CAAC;oBAC5B,GAAG,MAAM;oBACT,mBAAmB,EAAE,KAAK;iBAC3B,CAAC,CAAC;YACL,CAAC;YACD,IAAI,KAAK,EAAE,CAAC;gBACV,mBAAmB,GAAG,EAAE,GAAG,mBAAmB,EAAE,GAAG,KAAK,EAAE,CAAC;gBAC3D,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,OAAO,CACxB,CAAC,IAAI,EAAE,EAAE,CAAC,OAAO,sBAAsB,CAAC,IAAI,CAAC,CAC9C,CAAC;YACJ,CAAC;YACD,IAAI,MAAM,KAAK,eAAe,IAAI,MAAM,KAAK,aAAa,EAAE,CAAC;gBAC3D,OAAO,CAAC,sBAAsB,GAAG,IAAI,CAAC;YACxC,CAAC;QACH,CAAC;aAAM,IAAI,OAAO,CAAC,gBAAgB,EAAE,CAAC;YACpC,IAAI,sBAAsB,EAAE,CAAC;gBAC3B,MAAM,EAAE,MAAM,EAAE,KAAK,EAAE,GAAG,MAAM,sBAAsB,CAAC;oBACrD,GAAG,OAAO;oBACV,OAAO;oBACP,UAAU;oBACV,cAAc;oBACd,WAAW;oBACX,kBAAkB,EAAE,kBAAmB;oBACvC,QAAQ;oBACR,eAAe,EAAE,eAAgB;oBACjC,kBAAkB,EAAE,KAAK;iBAC1B,CAAC,CAAC;gBACH,IAAI,MAAM,KAAK,aAAa,EAAE,CAAC;oBAC7B,yBAAyB;oBACzB,IAAI,CAAC,mBAAmB,CAAC,WAAW,CAAC,EAAE,CAAC;wBACtC,sBAAsB,CAAC,WAAW,CAAC,GAAG,kBAAmB,CAAC;oBAC5D,CAAC;gBACH,CAAC;qBAAM,IAAI,MAAM,KAAK,iBAAiB,EAAE,CAAC;oBACxC,eAAM,CAAC,KAAK,CACV,cAAc,OAAO,OAAO,UAAU,qCAAqC,CAC5E,CAAC;gBACJ,CAAC;qBAAM,CAAC;oBACN,oBAAoB;oBACpB,IAAI,mBAAmB,EAAE,CAAC;wBACxB,eAAM,CAAC,KAAK,CACV,EAAE,QAAQ,EAAE,OAAO,EAAE,MAAM,EAAE,EAC7B,2DAA2D,CAC5D,CAAC;wBACF,OAAO,sBAAsB,CAAC;4BAC5B,GAAG,MAAM;4BACT,mBAAmB,EAAE,KAAK;yBAC3B,CAAC,CAAC;oBACL,CAAC;oBACD,IAAI,KAAK,EAAE,CAAC;wBACV,mBAAmB,GAAG,EAAE,GAAG,mBAAmB,EAAE,GAAG,KAAK,EAAE,CAAC;wBAC3D,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,OAAO,CACxB,CAAC,IAAI,EAAE,EAAE,CAAC,OAAO,sBAAsB,CAAC,IAAI,CAAC,CAC9C,CAAC;oBACJ,CAAC;gBACH,CAAC;YACH,CAAC;iBAAM,CAAC;gBACN,eAAM,CAAC,KAAK,CACV,EAAE,OAAO,EAAE,EACX,iDAAiD,CAClD,CAAC;gBACF,IAAI,CAAC,mBAAmB,CAAC,WAAW,CAAC,EAAE,CAAC;oBACtC,sBAAsB,CAAC,WAAW,CAAC,GAAG,kBAAmB,CAAC;gBAC5D,CAAC;YACH,CAAC;QACH,CAAC;aAAM,CAAC;YACN,MAAM,kBAAkB,GAAG,IAAA,aAAG,EAAC,OAAO,EAAE,oBAAoB,CAAC,CAAC;YAC9D,MAAM,gBAAgB,GAAG,IAAA,aAAG,EAAC,OAAO,EAAE,kBAAkB,CAAC,CAAC;YAC1D,IAAI,CAAC,gBAAgB,EAAE,CAAC;gBACtB,IAAI,GAAG,GAAG,MAAM,IAAA,4BAAa,EAC3B,OAAO,EACP,kBAAmB,EACnB,mBAAmB,EACnB,WAAW,CACZ,CAAC;gBACF,WAAW,GAAG,KAAK,CAAC;gBACpB,IAAI,GAAG,EAAE,CAAC;oBACR,IACE,kBAAkB;wBAClB,OAAO,CAAC,WAAW;wBACnB,OAAO,CAAC,kBAAkB,EAC1B,CAAC;wBACD,MAAM,EAAE,aAAa,EAAE,GAAG,MAAM,kBAAkB,CAChD,GAAG,EACH,OAAO,CAAC,kBAAkB,EAC1B,OAAO,CAAC,WAAW,EACnB,WAAW,CACZ,CAAC;wBACF,GAAG,GAAG,aAAa,CAAC;oBACtB,CAAC;oBACD,IAAI,GAAG,KAAK,kBAAkB,EAAE,CAAC;wBAC/B,eAAM,CAAC,KAAK,CAAC,EAAE,WAAW,EAAE,OAAO,EAAE,EAAE,oBAAoB,CAAC,CAAC;oBAC/D,CAAC;yBAAM,CAAC;wBACN,eAAM,CAAC,KAAK,CAAC,EAAE,WAAW,EAAE,OAAO,EAAE,EAAE,kBAAkB,CAAC,CAAC;wBAC3D,mBAAmB,CAAC,WAAW,CAAC,GAAG,GAAI,CAAC;wBACxC,OAAO,sBAAsB,CAAC,WAAW,CAAC,CAAC;oBAC7C,CAAC;oBACD,SAAS;gBACX,CAAC;qBAAM,IAAI,mBAAmB,EAAE,CAAC;oBAC/B,OAAO,sBAAsB,CAAC;wBAC5B,GAAG,MAAM;wBACT,mBAAmB,EAAE,KAAK;qBAC3B,CAAC,CAAC;gBACL,CAAC;gBACD,eAAM,CAAC,KAAK,CAAC,EAAE,WAAW,EAAE,OAAO,EAAE,EAAE,uBAAuB,CAAC,CAAC;gBAChE,MAAM,IAAI,KAAK,CAAC,0CAAyB,CAAC,CAAC;YAC7C,CAAC;YACD,IAAI,UAAU,GAAG,MAAM,gBAAgB,CAAC;gBACtC,WAAW,EAAE,kBAAmB;gBAChC,OAAO;aACR,CAAC,CAAC;YACH,IACE,UAAU;gBACV,kBAAkB;gBAClB,OAAO,CAAC,WAAW;gBACnB,OAAO,CAAC,kBAAkB,EAC1B,CAAC;gBACD,MAAM,EAAE,aAAa,EAAE,GAAG,MAAM,kBAAkB,CAChD,UAAU,EACV,OAAO,CAAC,kBAAkB,EAC1B,OAAO,CAAC,WAAW,EACnB,WAAW,CACZ,CAAC;gBACF,UAAU,GAAG,aAAa,CAAC;YAC7B,CAAC;YACD,IAAI,CAAC,UAAU,EAAE,CAAC;gBAChB,IAAI,mBAAmB,EAAE,CAAC;oBACxB,eAAM,CAAC,KAAK,CACV,EAAE,WAAW,EAAE,OAAO,EAAE,EACxB,8CAA8C,CAC/C,CAAC;oBACF,OAAO,sBAAsB,CAAC;wBAC5B,GAAG,MAAM;wBACT,mBAAmB,EAAE,KAAK;qBAC3B,CAAC,CAAC;gBACL,CAAC;gBACD,eAAM,CAAC,KAAK,CACV,EAAE,eAAe,EAAE,kBAAkB,EAAE,MAAM,EAAE,OAAO,EAAE,EACxD,qBAAqB,CACtB,CAAC;gBACF,MAAM,IAAI,KAAK,CAAC,0CAAyB,CAAC,CAAC;YAC7C,CAAC;YACD,IAAI,UAAU,KAAK,kBAAkB,EAAE,CAAC;gBACtC,IAAI,mBAAmB,EAAE,CAAC;oBACxB,gDAAgD;oBAChD,eAAM,CAAC,KAAK,CACV,EAAE,WAAW,EAAE,OAAO,EAAE,EACxB,kDAAkD,CACnD,CAAC;oBACF,OAAO,sBAAsB,CAAC;wBAC5B,GAAG,MAAM;wBACT,mBAAmB,EAAE,KAAK;qBAC3B,CAAC,CAAC;gBACL,CAAC;gBACD,eAAM,CAAC,KAAK,CACV,YAAY,OAAO,OAAO,IAAA,qBAAY,EAAC,WAAW,EAAE,QAAQ,CAAC,EAAE,CAChE,CAAC;gBACF,mBAAmB,CAAC,WAAW,CAAC,GAAG,UAAU,CAAC;gBAC9C,OAAO,sBAAsB,CAAC,WAAW,CAAC,CAAC;YAC7C,CAAC;YACD,IAAI,UAAU,KAAK,kBAAkB,EAAE,CAAC;gBACtC,IAAI,OAAO,CAAC,OAAO,KAAK,gBAAgB,EAAE,CAAC;oBACzC,mBAAmB,CAAC,WAAW,CAAC,GAAG,UAAU,CAAC;oBAC9C,OAAO,sBAAsB,CAAC,WAAW,CAAC,CAAC;gBAC7C,CAAC;YACH,CAAC;QACH,CAAC;IACH,CAAC;IACD,MAAM,mBAAmB,GAAmB,MAAM,CAAC,IAAI,CACrD,mBAAmB,CACpB,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC;QACf,IAAI,EAAE,UAAU;QAChB,IAAI,EAAE,IAAI;QACV,QAAQ,EAAE,mBAAmB,CAAC,IAAI,CAAC;KACpC,CAAC,CAAC,CAAC;IACJ,MAAM,gBAAgB,GAAiB,EAAE,CAAC;IAC1C,MAAM,cAAc,GAAoB,EAAE,CAAC;IAC3C,MAAM,eAAe,GAAqB,EAAE,CAAC;IAC7C,qBAAqB;IACrB,IAAI,YAAE,CAAC,aAAa,CAAC,mBAAmB,CAAC,EAAE,CAAC;QAC1C,eAAM,CAAC,KAAK,CAAC,yCAAyC,CAAC,CAAC;IAC1D,CAAC;IACD,KAAK,MAAM,WAAW,IAAI,mBAAmB,EAAE,CAAC;QAC9C,MAAM,WAAW,GAAG,sBAAsB,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;QAC7D,MAAM,QAAQ,GAAG,mBAAmB,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;QACvD,IAAI,YAAE,CAAC,WAAW,CAAC,QAAQ,CAAC,EAAE,CAAC;YAC7B,KAAK,MAAM,OAAO,IAAI,QAAQ,EAAE,CAAC;gBAC/B,MAAM,OAAO,GAAG,MAAM,sBAAsB,CAAC,OAAO,EAAE;oBACpD,eAAe,EAAE,WAAW,CAAC,IAAI;oBACjC,WAAW;oBACX,cAAc;oBACd,qBAAqB,EAAE,WAAW,CAAC,QAAS,CAAC,QAAQ,EAAE;oBACvD,MAAM,EAAE,6BAA6B,CACnC,MAAM,EACN,OAAO,EACP,WAAW,CAAC,IAAI,CACjB;iBACF,CAAC,CAAC;gBACH,4BAA4B,CAC1B,OAAO,EACP,gBAAgB,EAChB,cAAc,EACd,eAAe,CAChB,CAAC;YACJ,CAAC;QACH,CAAC;IACH,CAAC;IACD,MAAM,sBAAsB,GAAmB,MAAM,CAAC,IAAI,CACxD,sBAAsB,CACvB,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC;QACf,IAAI,EAAE,UAAU;QAChB,IAAI,EAAE,IAAI;QACV,QAAQ,EAAE,sBAAsB,CAAC,IAAI,CAAC;KACvC,CAAC,CAAC,CAAC;IACJ,qBAAqB;IACrB,IAAI,YAAE,CAAC,aAAa,CAAC,sBAAsB,CAAC,EAAE,CAAC;QAC7C,eAAM,CAAC,KAAK,CAAC,4CAA4C,CAAC,CAAC;IAC7D,CAAC;IACD,KAAK,MAAM,WAAW,IAAI,sBAAsB,EAAE,CAAC;QACjD,MAAM,WAAW,GAAG,sBAAsB,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;QAC7D,MAAM,QAAQ,GAAG,mBAAmB,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;QACvD,IAAI,YAAE,CAAC,WAAW,CAAC,QAAQ,CAAC,EAAE,CAAC;YAC7B,KAAK,MAAM,OAAO,IAAI,QAAQ,EAAE,CAAC;gBAC/B,MAAM,OAAO,GAAG,MAAM,sBAAsB,CAAC,OAAO,EAAE;oBACpD,eAAe,EAAE,WAAW,CAAC,IAAI;oBACjC,WAAW;oBACX,cAAc;oBACd,qBAAqB,EAAE,WAAW,CAAC,QAAS,CAAC,QAAQ,EAAE;oBACvD,MAAM,EAAE,6BAA6B,CACnC,MAAM,EACN,OAAO,EACP,WAAW,CAAC,IAAI,CACjB;iBACF,CAAC,CAAC;gBACH,4BAA4B,CAC1B,OAAO,EACP,gBAAgB,EAChB,cAAc,EACd,eAAe,CAChB,CAAC;gBACF,IAAI,YAAE,CAAC,aAAa,CAAC,OAAO,CAAC,EAAE,CAAC;oBAC9B,mBAAmB,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;gBACxC,CAAC;YACH,CAAC;QACH,CAAC;IACH,CAAC;IACD,IAAI,CAAC,mBAAmB,EAAE,CAAC;QACzB,4DAA4D;QAC5D,qBAAqB;QACrB,IAAI,YAAE,CAAC,aAAa,CAAC,wBAAwB,CAAC,EAAE,CAAC;YAC/C,eAAM,CAAC,KAAK,CAAC,8CAA8C,CAAC,CAAC;QAC/D,CAAC;QACD,KAAK,MAAM,eAAe,IAAI,wBAAwB,EAAE,CAAC;YACvD,MAAM,QAAQ,GAAG,mBAAmB,CAAC,eAAe,CAAC,CAAC;YACtD,IAAI,YAAE,CAAC,WAAW,CAAC,QAAQ,CAAC,EAAE,CAAC;gBAC7B,KAAK,MAAM,OAAO,IAAI,QAAQ,EAAE,CAAC;oBAC/B,MAAM,QAAQ,GACZ,mBAAmB,CAAC,eAAe,CAAC;wBACpC,CAAC,MAAM,IAAA,aAAO,EAAC,eAAe,EAAE,MAAM,CAAC,UAAU,CAAC,CAAC,CAAC;oBACtD,MAAM,OAAO,GAAG,MAAM,sBAAsB,CAAC,OAAO,EAAE;wBACpD,eAAe;wBACf,WAAW,EAAE,EAAE;wBACf,qBAAqB,EAAE,QAAS;wBAChC,MAAM,EAAE,6BAA6B,CACnC,MAAM,EACN,OAAO,EACP,eAAe,CAChB;qBACF,CAAC,CAAC;oBACH,4BAA4B,CAC1B,OAAO,EACP,gBAAgB,EAChB,cAAc,EACd,eAAe,CAChB,CAAC;gBACJ,CAAC;YACH,CAAC;QACH,CAAC;IACH,CAAC;IACD,OAAO;QACL,mBAAmB,EAAE,oCAAoC;QACzD,mBAAmB;QACnB,gBAAgB;QAChB,cAAc;QACd,eAAe;KAChB,CAAC;AACJ,CAAC;AAvWD,wDAuWC;AAED,yBAAyB;AACzB,SAAS,6BAA6B,CACpC,MAAoB,EACpB,OAAe,EACf,eAAuB;IAEvB,MAAM,aAAa,GAAG,EAAE,GAAG,MAAM,EAAE,CAAC;IACpC,IAAI,YAAE,CAAC,aAAa,CAAC,aAAa,CAAC,YAAY,EAAE,CAAC,OAAO,CAAC,CAAC,EAAE,CAAC;QAC5D,MAAM,mBAAmB,GACvB,aAAa,CAAC,YAAY,EAAE,CAAC,OAAO,CAAC,CAAC;QACxC,MAAM,WAAW,GAAG,mBAAmB,CAAC,IAAI,CAC1C,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,WAAW,KAAK,eAAe,CACzC,CAAC;QACF,IACE,WAAW;YACX,YAAE,CAAC,aAAa,CAAC,aAAa,CAAC,SAAS,CAAC;YACzC,YAAE,CAAC,aAAa,CAAC,WAAW,CAAC,SAAS,CAAC,EACvC,CAAC;YACD,aAAa,CAAC,SAAS,GAAG,WAAW,CAAC,SAAS,CAAC;QAClD,CAAC;IACH,CAAC;IACD,OAAO,aAAa,CAAC;AACvB,CAAC;AAED,KAAK,UAAU,sBAAsB,CACnC,OAAe,EACf,cAA8B;IAE9B,MAAM,eAAe,GAAG,IAAA,aAAG,EAAC,OAAO,EAAE,iBAAiB,CAAC,CAAC;IACxD,IAAI,eAAe,EAAE,CAAC;QACpB,OAAO,MAAM,eAAe,CAAC,cAAc,CAAC,CAAC;IAC/C,CAAC;IACD,OAAO,IAAI,CAAC;AACd,CAAC;AAED,SAAS,4BAA4B,CACnC,OAAuC,EACvC,gBAA8B,EAC9B,cAA+B,EAC/B,eAAiC;IAEjC,IAAI,YAAE,CAAC,aAAa,CAAC,OAAO,CAAC,EAAE,CAAC;QAC9B,KAAK,MAAM,GAAG,IAAI,OAAO,EAAE,CAAC;YAC1B,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,aAAa,EAAE,GAAG,GAAG,CAAC;YAC5C,IAAI,IAAI,EAAE,CAAC;gBACT,gBAAgB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YAC9B,CAAC;YAED,IAAI,aAAa,EAAE,CAAC;gBAClB,cAAc,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;YACrC,CAAC;YAED,IAAI,MAAM,EAAE,CAAC;gBACX,eAAe,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YAC/B,CAAC;QACH,CAAC;IACH,CAAC;AACH,CAAC","sourcesContent":["/* eslint-disable @typescript-eslint/no-unnecessary-type-assertion */\nimport is from '@sindresorhus/is';\nimport { WORKER_FILE_UPDATE_FAILED } from '../../../../constants/error-messages';\nimport { logger } from '../../../../logger';\nimport { get } from '../../../../modules/manager';\nimport type {\n  ArtifactError,\n  ArtifactNotice,\n  PackageDependency,\n  PackageFile,\n  UpdateArtifact,\n  UpdateArtifactsResult,\n} from '../../../../modules/manager/types';\nimport { getFile } from '../../../../util/git';\nimport type { FileAddition, FileChange } from '../../../../util/git/types';\nimport { coerceString } from '../../../../util/string';\nimport type { BranchConfig } from '../../../types';\nimport { doAutoReplace } from './auto-replace';\n\nexport interface PackageFilesResult {\n  artifactErrors: ArtifactError[];\n  reuseExistingBranch?: boolean;\n  updatedPackageFiles: FileChange[];\n  updatedArtifacts: FileChange[];\n  artifactNotices: ArtifactNotice[];\n}\n\nasync function getFileContent(\n  updatedFileContents: Record<string, string>,\n  filePath: string,\n  config: BranchConfig,\n): Promise<string | null> {\n  let fileContent: string | null = updatedFileContents[filePath];\n  if (!fileContent) {\n    fileContent = await getFile(\n      filePath,\n      config.reuseExistingBranch ? config.branchName : config.baseBranch,\n    );\n  }\n  return fileContent;\n}\n\nexport async function getUpdatedPackageFiles(\n  config: BranchConfig,\n): Promise<PackageFilesResult> {\n  logger.trace({ config });\n  const reuseExistingBranch = config.reuseExistingBranch!;\n  logger.debug(\n    `manager.getUpdatedPackageFiles() reuseExistingBranch=${reuseExistingBranch}`,\n  );\n  let updatedFileContents: Record<string, string> = {};\n  const nonUpdatedFileContents: Record<string, string> = {};\n  const packageFileManagers: Record<string, Set<string>> = {};\n  const packageFileUpdatedDeps: Record<string, PackageDependency[]> = {};\n  const lockFileMaintenanceFiles = [];\n  let firstUpdate = true;\n  for (const upgrade of config.upgrades) {\n    const manager = upgrade.manager!;\n    const packageFile = upgrade.packageFile!;\n    const depName = upgrade.depName!;\n    // TODO: fix types, can be undefined (#22198)\n    const newVersion = upgrade.newVersion!;\n    const currentVersion = upgrade.currentVersion!;\n    const updateLockedDependency = get(manager, 'updateLockedDependency')!;\n    packageFileManagers[packageFile] ??= new Set<string>();\n    packageFileManagers[packageFile].add(manager);\n    packageFileUpdatedDeps[packageFile] ??= [];\n    packageFileUpdatedDeps[packageFile].push({ ...upgrade });\n    const packageFileContent = await getFileContent(\n      updatedFileContents,\n      packageFile,\n      config,\n    );\n    let lockFileContent: string | null = null;\n    const lockFile = upgrade.lockFile ?? upgrade.lockFiles?.[0] ?? '';\n    if (lockFile) {\n      lockFileContent = await getFileContent(\n        updatedFileContents,\n        lockFile,\n        config,\n      );\n    }\n    // istanbul ignore if\n    if (\n      reuseExistingBranch &&\n      (!packageFileContent || (lockFile && !lockFileContent))\n    ) {\n      logger.debug(\n        { packageFile, depName },\n        'Rebasing branch after file not found',\n      );\n      return getUpdatedPackageFiles({\n        ...config,\n        reuseExistingBranch: false,\n      });\n    }\n    if (upgrade.updateType === 'lockFileMaintenance') {\n      lockFileMaintenanceFiles.push(packageFile);\n    } else if (upgrade.isRemediation) {\n      const { status, files } = await updateLockedDependency({\n        ...upgrade,\n        depName,\n        newVersion,\n        currentVersion,\n        packageFile,\n        packageFileContent: packageFileContent!,\n        lockFile,\n        lockFileContent: lockFileContent!,\n        allowParentUpdates: true,\n        allowHigherOrRemoved: true,\n      });\n      if (reuseExistingBranch && status !== 'already-updated') {\n        logger.debug(\n          { lockFile, depName, status },\n          'Need to retry branch as it is not already up-to-date',\n        );\n        return getUpdatedPackageFiles({\n          ...config,\n          reuseExistingBranch: false,\n        });\n      }\n      if (files) {\n        updatedFileContents = { ...updatedFileContents, ...files };\n        Object.keys(files).forEach(\n          (file) => delete nonUpdatedFileContents[file],\n        );\n      }\n      if (status === 'update-failed' || status === 'unsupported') {\n        upgrade.remediationNotPossible = true;\n      }\n    } else if (upgrade.isLockfileUpdate) {\n      if (updateLockedDependency) {\n        const { status, files } = await updateLockedDependency({\n          ...upgrade,\n          depName,\n          newVersion,\n          currentVersion,\n          packageFile,\n          packageFileContent: packageFileContent!,\n          lockFile,\n          lockFileContent: lockFileContent!,\n          allowParentUpdates: false,\n        });\n        if (status === 'unsupported') {\n          // incompatible lock file\n          if (!updatedFileContents[packageFile]) {\n            nonUpdatedFileContents[packageFile] = packageFileContent!;\n          }\n        } else if (status === 'already-updated') {\n          logger.debug(\n            `Upgrade of ${depName} to ${newVersion} is already done in existing branch`,\n          );\n        } else {\n          // something changed\n          if (reuseExistingBranch) {\n            logger.debug(\n              { lockFile, depName, status },\n              'Need to retry branch as upgrade requirements are not mets',\n            );\n            return getUpdatedPackageFiles({\n              ...config,\n              reuseExistingBranch: false,\n            });\n          }\n          if (files) {\n            updatedFileContents = { ...updatedFileContents, ...files };\n            Object.keys(files).forEach(\n              (file) => delete nonUpdatedFileContents[file],\n            );\n          }\n        }\n      } else {\n        logger.debug(\n          { manager },\n          'isLockFileUpdate without updateLockedDependency',\n        );\n        if (!updatedFileContents[packageFile]) {\n          nonUpdatedFileContents[packageFile] = packageFileContent!;\n        }\n      }\n    } else {\n      const bumpPackageVersion = get(manager, 'bumpPackageVersion');\n      const updateDependency = get(manager, 'updateDependency');\n      if (!updateDependency) {\n        let res = await doAutoReplace(\n          upgrade,\n          packageFileContent!,\n          reuseExistingBranch,\n          firstUpdate,\n        );\n        firstUpdate = false;\n        if (res) {\n          if (\n            bumpPackageVersion &&\n            upgrade.bumpVersion &&\n            upgrade.packageFileVersion\n          ) {\n            const { bumpedContent } = await bumpPackageVersion(\n              res,\n              upgrade.packageFileVersion,\n              upgrade.bumpVersion,\n              packageFile,\n            );\n            res = bumpedContent;\n          }\n          if (res === packageFileContent) {\n            logger.debug({ packageFile, depName }, 'No content changed');\n          } else {\n            logger.debug({ packageFile, depName }, 'Contents updated');\n            updatedFileContents[packageFile] = res!;\n            delete nonUpdatedFileContents[packageFile];\n          }\n          continue;\n        } else if (reuseExistingBranch) {\n          return getUpdatedPackageFiles({\n            ...config,\n            reuseExistingBranch: false,\n          });\n        }\n        logger.error({ packageFile, depName }, 'Could not autoReplace');\n        throw new Error(WORKER_FILE_UPDATE_FAILED);\n      }\n      let newContent = await updateDependency({\n        fileContent: packageFileContent!,\n        upgrade,\n      });\n      if (\n        newContent &&\n        bumpPackageVersion &&\n        upgrade.bumpVersion &&\n        upgrade.packageFileVersion\n      ) {\n        const { bumpedContent } = await bumpPackageVersion(\n          newContent,\n          upgrade.packageFileVersion,\n          upgrade.bumpVersion,\n          packageFile,\n        );\n        newContent = bumpedContent;\n      }\n      if (!newContent) {\n        if (reuseExistingBranch) {\n          logger.debug(\n            { packageFile, depName },\n            'Rebasing branch after error updating content',\n          );\n          return getUpdatedPackageFiles({\n            ...config,\n            reuseExistingBranch: false,\n          });\n        }\n        logger.debug(\n          { existingContent: packageFileContent, config: upgrade },\n          'Error updating file',\n        );\n        throw new Error(WORKER_FILE_UPDATE_FAILED);\n      }\n      if (newContent !== packageFileContent) {\n        if (reuseExistingBranch) {\n          // This ensure it's always 1 commit from the bot\n          logger.debug(\n            { packageFile, depName },\n            'Need to update package file so will rebase first',\n          );\n          return getUpdatedPackageFiles({\n            ...config,\n            reuseExistingBranch: false,\n          });\n        }\n        logger.debug(\n          `Updating ${depName} in ${coerceString(packageFile, lockFile)}`,\n        );\n        updatedFileContents[packageFile] = newContent;\n        delete nonUpdatedFileContents[packageFile];\n      }\n      if (newContent === packageFileContent) {\n        if (upgrade.manager === 'git-submodules') {\n          updatedFileContents[packageFile] = newContent;\n          delete nonUpdatedFileContents[packageFile];\n        }\n      }\n    }\n  }\n  const updatedPackageFiles: FileAddition[] = Object.keys(\n    updatedFileContents,\n  ).map((name) => ({\n    type: 'addition',\n    path: name,\n    contents: updatedFileContents[name],\n  }));\n  const updatedArtifacts: FileChange[] = [];\n  const artifactErrors: ArtifactError[] = [];\n  const artifactNotices: ArtifactNotice[] = [];\n  // istanbul ignore if\n  if (is.nonEmptyArray(updatedPackageFiles)) {\n    logger.debug('updateArtifacts for updatedPackageFiles');\n  }\n  for (const packageFile of updatedPackageFiles) {\n    const updatedDeps = packageFileUpdatedDeps[packageFile.path];\n    const managers = packageFileManagers[packageFile.path];\n    if (is.nonEmptySet(managers)) {\n      for (const manager of managers) {\n        const results = await managerUpdateArtifacts(manager, {\n          packageFileName: packageFile.path,\n          updatedDeps,\n          // TODO #22198\n          newPackageFileContent: packageFile.contents!.toString(),\n          config: patchConfigForArtifactsUpdate(\n            config,\n            manager,\n            packageFile.path,\n          ),\n        });\n        processUpdateArtifactResults(\n          results,\n          updatedArtifacts,\n          artifactErrors,\n          artifactNotices,\n        );\n      }\n    }\n  }\n  const nonUpdatedPackageFiles: FileAddition[] = Object.keys(\n    nonUpdatedFileContents,\n  ).map((name) => ({\n    type: 'addition',\n    path: name,\n    contents: nonUpdatedFileContents[name],\n  }));\n  // istanbul ignore if\n  if (is.nonEmptyArray(nonUpdatedPackageFiles)) {\n    logger.debug('updateArtifacts for nonUpdatedPackageFiles');\n  }\n  for (const packageFile of nonUpdatedPackageFiles) {\n    const updatedDeps = packageFileUpdatedDeps[packageFile.path];\n    const managers = packageFileManagers[packageFile.path];\n    if (is.nonEmptySet(managers)) {\n      for (const manager of managers) {\n        const results = await managerUpdateArtifacts(manager, {\n          packageFileName: packageFile.path,\n          updatedDeps,\n          // TODO #22198\n          newPackageFileContent: packageFile.contents!.toString(),\n          config: patchConfigForArtifactsUpdate(\n            config,\n            manager,\n            packageFile.path,\n          ),\n        });\n        processUpdateArtifactResults(\n          results,\n          updatedArtifacts,\n          artifactErrors,\n          artifactNotices,\n        );\n        if (is.nonEmptyArray(results)) {\n          updatedPackageFiles.push(packageFile);\n        }\n      }\n    }\n  }\n  if (!reuseExistingBranch) {\n    // Only perform lock file maintenance if it's a fresh commit\n    // istanbul ignore if\n    if (is.nonEmptyArray(lockFileMaintenanceFiles)) {\n      logger.debug('updateArtifacts for lockFileMaintenanceFiles');\n    }\n    for (const packageFileName of lockFileMaintenanceFiles) {\n      const managers = packageFileManagers[packageFileName];\n      if (is.nonEmptySet(managers)) {\n        for (const manager of managers) {\n          const contents =\n            updatedFileContents[packageFileName] ||\n            (await getFile(packageFileName, config.baseBranch));\n          const results = await managerUpdateArtifacts(manager, {\n            packageFileName,\n            updatedDeps: [],\n            newPackageFileContent: contents!,\n            config: patchConfigForArtifactsUpdate(\n              config,\n              manager,\n              packageFileName,\n            ),\n          });\n          processUpdateArtifactResults(\n            results,\n            updatedArtifacts,\n            artifactErrors,\n            artifactNotices,\n          );\n        }\n      }\n    }\n  }\n  return {\n    reuseExistingBranch, // Need to overwrite original config\n    updatedPackageFiles,\n    updatedArtifacts,\n    artifactErrors,\n    artifactNotices,\n  };\n}\n\n// workaround, see #27319\nfunction patchConfigForArtifactsUpdate(\n  config: BranchConfig,\n  manager: string,\n  packageFileName: string,\n): BranchConfig {\n  const updatedConfig = { ...config };\n  if (is.nonEmptyArray(updatedConfig.packageFiles?.[manager])) {\n    const managerPackageFiles: PackageFile[] =\n      updatedConfig.packageFiles?.[manager];\n    const packageFile = managerPackageFiles.find(\n      (p) => p.packageFile === packageFileName,\n    );\n    if (\n      packageFile &&\n      is.nonEmptyArray(updatedConfig.lockFiles) &&\n      is.nonEmptyArray(packageFile.lockFiles)\n    ) {\n      updatedConfig.lockFiles = packageFile.lockFiles;\n    }\n  }\n  return updatedConfig;\n}\n\nasync function managerUpdateArtifacts(\n  manager: string,\n  updateArtifact: UpdateArtifact,\n): Promise<UpdateArtifactsResult[] | null> {\n  const updateArtifacts = get(manager, 'updateArtifacts');\n  if (updateArtifacts) {\n    return await updateArtifacts(updateArtifact);\n  }\n  return null;\n}\n\nfunction processUpdateArtifactResults(\n  results: UpdateArtifactsResult[] | null,\n  updatedArtifacts: FileChange[],\n  artifactErrors: ArtifactError[],\n  artifactNotices: ArtifactNotice[],\n): void {\n  if (is.nonEmptyArray(results)) {\n    for (const res of results) {\n      const { file, notice, artifactError } = res;\n      if (file) {\n        updatedArtifacts.push(file);\n      }\n\n      if (artifactError) {\n        artifactErrors.push(artifactError);\n      }\n\n      if (notice) {\n        artifactNotices.push(notice);\n      }\n    }\n  }\n}\n"]}