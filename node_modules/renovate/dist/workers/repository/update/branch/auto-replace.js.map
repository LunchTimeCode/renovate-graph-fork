{"version":3,"file":"auto-replace.js","sourceRoot":"","sources":["../../../../../lib/workers/repository/update/branch/auto-replace.ts"],"names":[],"mappings":";;;;AAAA,cAAc;AACd,kEAAkC;AAClC,yEAAiF;AACjF,+CAA4C;AAC5C,yDAAiE;AAEjE,4CAAqD;AACrD,kDAA6D;AAC7D,oDAA6D;AAC7D,wDAAoD;AAG7C,KAAK,UAAU,mBAAmB,CACvC,OAA4B,EAC5B,UAAkB;IAElB,MAAM,EAAE,OAAO,EAAE,WAAW,EAAE,QAAQ,EAAE,GAAG,OAAO,CAAC;IACnD,IAAI,UAA6B,CAAC;IAClC,IAAI,CAAC;QACH,MAAM,UAAU,GAAG,MAAM,IAAA,4BAAkB,EACzC,OAAO,EACP,UAAU,EACV,WAAY,EACZ,OAAO,CACR,CAAC;QACF,qBAAqB;QACrB,IAAI,CAAC,UAAU,EAAE,CAAC;YAChB,2BAA2B;YAC3B,eAAM,CAAC,KAAK,CACV,qBAAqB,WAAY,aAAa,OAAO,qEAAqE,CAC3H,CAAC;YACF,eAAM,CAAC,KAAK,CACV,EAAE,WAAW,EAAE,OAAO,EAAE,UAAU,EAAE,EACpC,uCAAuC,CACxC,CAAC;YACF,OAAO,KAAK,CAAC;QACf,CAAC;QACD,qBAAqB;QACrB,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,MAAM,EAAE,CAAC;YAC7B,eAAM,CAAC,KAAK,CACV,aAAa,WAAY,sFAAsF,CAChH,CAAC;YACF,OAAO,KAAK,CAAC;QACf,CAAC;QACD,qBAAqB;QACrB,IAAI,YAAE,CAAC,MAAM,CAAC,QAAQ,CAAC,IAAI,QAAQ,IAAI,UAAU,CAAC,IAAI,CAAC,MAAM,EAAE,CAAC;YAC9D,eAAM,CAAC,KAAK,CACV,aAAa,WAAY,kDAAkD,CAC5E,CAAC;YACF,OAAO,KAAK,CAAC;QACf,CAAC;QACD,UAAU,GAAG,UAAU,CAAC,IAAI,CAAC,QAAS,CAAC,CAAC;IAC1C,CAAC;IAAC,OAAO,GAAG,EAAE,0BAA0B,CAAC,CAAC;QACxC,eAAM,CAAC,KAAK,CAAC,EAAE,OAAO,EAAE,WAAW,EAAE,GAAG,EAAE,EAAE,4BAA4B,CAAC,CAAC;IAC5E,CAAC;IAED,IAAI,CAAC,UAAW,EAAE,CAAC;QACjB,eAAM,CAAC,KAAK,CAAC,oBAAoB,WAAY,EAAE,CAAC,CAAC;QACjD,OAAO,KAAK,CAAC;IACf,CAAC;IAED,IACE,OAAO,CAAC,OAAO,KAAK,UAAU,CAAC,OAAO;QACtC,OAAO,CAAC,OAAO,KAAK,UAAU,CAAC,OAAO,EACtC,CAAC;QACD,eAAM,CAAC,KAAK,CACV;YACE,OAAO;YACP,WAAW;YACX,cAAc,EAAE,OAAO,CAAC,OAAO;YAC/B,UAAU,EAAE,UAAU,CAAC,OAAO;SAC/B,EACD,kBAAkB,CACnB,CAAC;QACF,OAAO,KAAK,CAAC;IACf,CAAC;IAED,IAAI,OAAO,CAAC,OAAO,IAAI,OAAO,CAAC,OAAO,KAAK,UAAU,CAAC,OAAO,EAAE,CAAC;QAC9D,eAAM,CAAC,KAAK,CACV;YACE,OAAO;YACP,WAAW;YACX,cAAc,EAAE,OAAO,CAAC,OAAO;YAC/B,UAAU,EAAE,UAAU,CAAC,OAAO;SAC/B,EACD,wBAAwB,CACzB,CAAC;QACF,OAAO,KAAK,CAAC;IACf,CAAC;IAED,IAAI,OAAO,CAAC,QAAQ,IAAI,OAAO,CAAC,QAAQ,KAAK,UAAU,CAAC,YAAY,EAAE,CAAC;QACrE,eAAM,CAAC,KAAK,CACV;YACE,OAAO;YACP,WAAW;YACX,aAAa,EAAE,OAAO,CAAC,QAAQ;YAC/B,UAAU,EAAE,UAAU,CAAC,YAAY;SACpC,EACD,sBAAsB,CACvB,CAAC;QACF,OAAO,KAAK,CAAC;IACf,CAAC;IAED,IACE,OAAO,CAAC,SAAS;QACjB,CAAC,OAAO,CAAC,WAAW,KAAK,IAAI,IAAI,OAAO,CAAC,aAAa,CAAC;QACvD,OAAO,CAAC,SAAS,KAAK,UAAU,CAAC,aAAa,EAC9C,CAAC;QACD,eAAM,CAAC,KAAK,CACV;YACE,OAAO;YACP,WAAW;YACX,aAAa,EAAE,OAAO,CAAC,SAAS;YAChC,UAAU,EAAE,UAAU,CAAC,aAAa;SACrC,EACD,uBAAuB,CACxB,CAAC;QACF,OAAO,KAAK,CAAC;IACf,CAAC;IAED,OAAO,IAAI,CAAC;AACd,CAAC;AA7GD,kDA6GC;AAED,SAAS,gBAAgB,CAAC,IAAyB;IACjD,uBAAuB;IACvB,OAAO,IAAI;SACR,GAAG,CACF,CAAC,GAAG,EAAE,EAAE,CACN,GAAG,CAAC,GAAG,CAAC,OAAO,IAAI,GAAG,CAAC,WAAW,CAAE,GAAG,CAAC,GAAG,CAAC,WAAW;QACrD,GAAG,CAAC,OAAO,CAAE,EAAE,CACpB;SACA,IAAI,CAAC,GAAG,CAAC,CAAC;AACf,CAAC;AAEM,KAAK,UAAU,4BAA4B,CAChD,OAA4B,EAC5B,aAAqB;IAErB,MAAM,EAAE,QAAQ,EAAE,OAAO,EAAE,WAAW,EAAE,GAAG,OAAO,CAAC;IACnD,IAAI,CAAC;QACH,MAAM,GAAG,GAAG,MAAM,IAAA,4BAAkB,EAClC,OAAO,EACP,aAAa,EACb,WAAY,EACZ,OAAO,CACP,CAAC;QACH,MAAM,UAAU,GAAG,GAAI,CAAC,IAAI,CAAC;QAC7B,OAAO,gBAAgB,CAAC,QAAS,CAAC,KAAK,gBAAgB,CAAC,UAAU,CAAC,CAAC;IACtE,CAAC;IAAC,OAAO,GAAG,EAAE,0BAA0B,CAAC,CAAC;QACxC,eAAM,CAAC,IAAI,CACT,EAAE,OAAO,EAAE,WAAW,EAAE,EACxB,0CAA0C,CAC3C,CAAC;QACF,OAAO,KAAK,CAAC;IACf,CAAC;AACH,CAAC;AArBD,oEAqBC;AAED,KAAK,UAAU,mBAAmB,CAChC,OAA4B,EAC5B,eAAuB;IAEvB,MAAM,EAAE,WAAW,EAAE,OAAO,EAAE,GAAG,OAAO,CAAC;IACzC,IAAI,CAAC,CAAC,MAAM,4BAA4B,CAAC,OAAO,EAAE,eAAe,CAAC,CAAC,EAAE,CAAC;QACpE,eAAM,CAAC,KAAK,CACV,EAAE,WAAW,EAAE,OAAO,EAAE,EACxB,6CAA6C,CAC9C,CAAC;QACF,OAAO,IAAI,CAAC;IACd,CAAC;IACD,IAAI,CAAC,CAAC,MAAM,mBAAmB,CAAC,OAAO,EAAE,eAAe,CAAC,CAAC,EAAE,CAAC;QAC3D,eAAM,CAAC,KAAK,CACV,EAAE,WAAW,EAAE,OAAO,EAAE,EACxB,0CAA0C,CAC3C,CAAC;QACF,OAAO,IAAI,CAAC;IACd,CAAC;IACD,2BAA2B;IAC3B,eAAM,CAAC,KAAK,CAAC,cAAc,OAAQ,OAAO,WAAY,qBAAqB,CAAC,CAAC;IAC7E,OAAO,eAAe,CAAC;AACzB,CAAC;AAEM,KAAK,UAAU,aAAa,CACjC,OAA4B,EAC5B,eAAuB,EACvB,mBAA4B,EAC5B,WAAW,GAAG,IAAI;IAElB,MAAM,EACJ,WAAW,EACX,OAAO,EACP,OAAO,EACP,YAAY,EACZ,QAAQ,EACR,aAAa,EACb,kBAAkB,EAClB,SAAS,EACT,sBAAsB,EACtB,yBAAyB,GAC1B,GAAG,OAAO,CAAC;IACZ;;;;MAIE;IACF,IAAI,mBAAmB,EAAE,CAAC;QACxB,OAAO,MAAM,mBAAmB,CAAC,OAAO,EAAE,eAAe,CAAC,CAAC;IAC7D,CAAC;IACD,MAAM,2BAA2B,GAC/B,YAAE,CAAC,MAAM,CAAC,OAAO,CAAC;QAClB,OAAO,KAAK,OAAO;QACnB,CAAC,YAAE,CAAC,SAAS,CAAC,OAAO,CAAC,aAAa,CAAC;YAClC,CAAC,OAAO,CAAC,aAAa,EAAE,QAAQ,CAAC,OAAQ,CAAC,CAAC,CAAC;IAChD,MAAM,aAAa,GAAG,OAAO,CAAC,aAAa,IAAI,YAAY,IAAI,aAAa,CAAC;IAC7E,eAAM,CAAC,KAAK,CAAC,EAAE,OAAO,EAAE,aAAa,EAAE,EAAE,2BAA2B,CAAC,CAAC;IACtE,IAAI,WAAmB,CAAC;IACxB,IAAI,2BAA2B,EAAE,CAAC;QAChC,MAAM,QAAQ,GAAG,eAAe,CAAC,OAAO,CAAC,OAAQ,CAAC,CAAC;QACnD,MAAM,QAAQ,GAAG,eAAe,CAAC,OAAO,CAAC,YAAa,CAAC,CAAC;QACxD,WAAW,GAAG,QAAQ,GAAG,QAAQ,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,QAAQ,CAAC;IAC1D,CAAC;SAAM,CAAC;QACN,WAAW,GAAG,eAAe,CAAC,OAAO,CAAC,aAAc,CAAC,CAAC;IACxD,CAAC;IACD,IAAI,WAAW,KAAK,CAAC,CAAC,EAAE,CAAC;QACvB,eAAM,CAAC,IAAI,CACT,EAAE,WAAW,EAAE,OAAO,EAAE,eAAe,EAAE,aAAa,EAAE,EACxD,4EAA4E,CAC7E,CAAC;QACF,OAAO,eAAe,CAAC;IACzB,CAAC;IACD,IAAI,CAAC;QACH,IAAI,SAAiB,CAAC;QACtB,IAAI,yBAAyB,IAAI,CAAC,OAAO,EAAE,CAAC;YAC1C,SAAS,GAAG,IAAA,kBAAO,EAAC,yBAAyB,EAAE,OAAO,EAAE,KAAK,CAAC,CAAC;QACjE,CAAC;aAAM,CAAC;YACN,SAAS,GAAG,aAAc,CAAC;YAE3B,MAAM,qBAAqB,GAAG,sBAAsB,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC;YAChE,IAAI,YAAY,IAAI,QAAQ,EAAE,CAAC;gBAC7B,SAAS,GAAG,SAAS,CAAC,OAAO,CAC3B,IAAA,aAAK,EAAC,IAAA,oBAAY,EAAC,YAAY,CAAC,EAAE,qBAAqB,CAAC,EACxD,QAAQ,CACT,CAAC;YACJ,CAAC;YACD,IAAI,OAAO,IAAI,OAAO,EAAE,CAAC;gBACvB,SAAS,GAAG,SAAS,CAAC,OAAO,CAC3B,IAAA,aAAK,EAAC,IAAA,oBAAY,EAAC,OAAO,CAAC,EAAE,qBAAqB,CAAC,EACnD,OAAO,CACR,CAAC;YACJ,CAAC;YACD,IAAI,aAAa,IAAI,SAAS,EAAE,CAAC;gBAC/B,SAAS,GAAG,SAAS,CAAC,OAAO,CAC3B,IAAA,aAAK,EAAC,IAAA,oBAAY,EAAC,aAAa,CAAC,EAAE,qBAAqB,CAAC,EACzD,SAAS,CACV,CAAC;YACJ,CAAC;iBAAM,IAAI,kBAAkB,IAAI,SAAS,EAAE,CAAC;gBAC3C,SAAS,GAAG,SAAS,CAAC,OAAO,CAC3B,IAAA,aAAK,EAAC,IAAA,oBAAY,EAAC,kBAAkB,CAAC,EAAE,qBAAqB,CAAC,EAC9D,SAAS,CACV,CAAC;YACJ,CAAC;QACH,CAAC;QACD,IAAI,CAAC,WAAW,IAAI,CAAC,MAAM,mBAAmB,CAAC,OAAO,EAAE,eAAe,CAAC,CAAC,EAAE,CAAC;YAC1E,eAAM,CAAC,KAAK,CACV,EAAE,WAAW,EAAE,OAAO,EAAE,EACxB,iDAAiD,CAClD,CAAC;YACF,OAAO,eAAe,CAAC;QACzB,CAAC;QACD,eAAM,CAAC,KAAK,CACV,EAAE,WAAW,EAAE,OAAO,EAAE,EACxB,4BAA4B,WAAW,EAAE,CAC1C,CAAC;QACF,IAAI,UAAU,GAAG,eAAe,CAAC;QACjC,IAAI,YAAY,GAAG,CAAC,OAAO,CAAC;QAC5B,IAAI,aAAa,GAAG,CAAC,QAAQ,CAAC;QAC9B,IAAI,UAAU,GAAG,WAAW,CAAC;QAC7B,uCAAuC;QACvC,OAAO,WAAW,GAAG,UAAU,CAAC,MAAM,EAAE,WAAW,IAAI,CAAC,EAAE,CAAC;YACzD,mDAAmD;YACnD,IAAI,2BAA2B,EAAE,CAAC;gBAChC,oCAAoC;gBACpC,IAAI,OAAO,IAAI,IAAA,gBAAO,EAAC,UAAU,EAAE,WAAW,EAAE,OAAQ,CAAC,EAAE,CAAC;oBAC1D,eAAM,CAAC,KAAK,CACV,EAAE,WAAW,EAAE,OAAO,EAAE,EACxB,0BAA0B,WAAW,EAAE,CACxC,CAAC;oBACF,IAAI,YAAY,EAAE,CAAC;wBACjB,UAAU,IAAI,CAAC,CAAC;wBAChB,WAAW,GAAG,UAAU,CAAC;wBACzB,MAAM,IAAA,mBAAc,EAAC,OAAO,CAAC,WAAY,EAAE,eAAe,CAAC,CAAC;wBAC5D,UAAU,GAAG,eAAe,CAAC;wBAC7B,YAAY,GAAG,KAAK,CAAC;wBACrB,aAAa,GAAG,KAAK,CAAC;wBACtB,SAAS;oBACX,CAAC;oBACD,uBAAuB;oBACvB,UAAU,GAAG,IAAA,kBAAS,EAAC,UAAU,EAAE,WAAW,EAAE,OAAQ,EAAE,OAAO,CAAC,CAAC;oBACnE,MAAM,IAAA,mBAAc,EAAC,OAAO,CAAC,WAAY,EAAE,UAAU,CAAC,CAAC;oBACvD,YAAY,GAAG,IAAI,CAAC;gBACtB,CAAC;qBAAM,IACL,QAAQ;oBACR,IAAA,gBAAO,EAAC,UAAU,EAAE,WAAW,EAAE,YAAa,CAAC,EAC/C,CAAC;oBACD,eAAM,CAAC,KAAK,CACV,EAAE,WAAW,EAAE,YAAY,EAAE,EAC7B,+BAA+B,WAAW,EAAE,CAC7C,CAAC;oBACF,iCAAiC;oBACjC,UAAU,GAAG,IAAA,kBAAS,EACpB,UAAU,EACV,WAAW,EACX,YAAa,EACb,QAAQ,CACT,CAAC;oBACF,MAAM,IAAA,mBAAc,EAAC,OAAO,CAAC,WAAY,EAAE,UAAU,CAAC,CAAC;oBACvD,aAAa,GAAG,IAAI,CAAC;gBACvB,CAAC;gBACD,IAAI,YAAY,IAAI,aAAa,EAAE,CAAC;oBAClC,IAAI,MAAM,mBAAmB,CAAC,OAAO,EAAE,UAAU,CAAC,EAAE,CAAC;wBACnD,OAAO,UAAU,CAAC;oBACpB,CAAC;oBACD,MAAM,IAAA,mBAAc,EAAC,OAAO,CAAC,WAAY,EAAE,eAAe,CAAC,CAAC;oBAC5D,UAAU,GAAG,eAAe,CAAC;oBAC7B,YAAY,GAAG,KAAK,CAAC;oBACrB,aAAa,GAAG,KAAK,CAAC;gBACxB,CAAC;YACH,CAAC;iBAAM,IAAI,IAAA,gBAAO,EAAC,UAAU,EAAE,WAAW,EAAE,aAAc,CAAC,EAAE,CAAC;gBAC5D,eAAM,CAAC,KAAK,CACV,EAAE,WAAW,EAAE,OAAO,EAAE,EACxB,wBAAwB,WAAW,EAAE,CACtC,CAAC;gBACF,iCAAiC;gBACjC,UAAU,GAAG,IAAA,kBAAS,EACpB,UAAU,EACV,WAAW,EACX,aAAc,EACd,SAAS,CACV,CAAC;gBACF,MAAM,IAAA,mBAAc,EAAC,OAAO,CAAC,WAAY,EAAE,UAAU,CAAC,CAAC;gBACvD,IAAI,MAAM,mBAAmB,CAAC,OAAO,EAAE,UAAU,CAAC,EAAE,CAAC;oBACnD,OAAO,UAAU,CAAC;gBACpB,CAAC;gBACD,MAAM,IAAA,mBAAc,EAAC,OAAO,CAAC,WAAY,EAAE,eAAe,CAAC,CAAC;gBAC5D,UAAU,GAAG,eAAe,CAAC;YAC/B,CAAC;QACH,CAAC;IACH,CAAC;IAAC,OAAO,GAAG,EAAE,0BAA0B,CAAC,CAAC;QACxC,eAAM,CAAC,KAAK,CAAC,EAAE,WAAW,EAAE,OAAO,EAAE,GAAG,EAAE,EAAE,qBAAqB,CAAC,CAAC;IACrE,CAAC;IACD,uBAAuB;IACvB,MAAM,IAAI,KAAK,CAAC,0CAAyB,CAAC,CAAC;AAC7C,CAAC;AA1KD,sCA0KC","sourcesContent":["// TODO #22198\nimport is from '@sindresorhus/is';\nimport { WORKER_FILE_UPDATE_FAILED } from '../../../../constants/error-messages';\nimport { logger } from '../../../../logger';\nimport { extractPackageFile } from '../../../../modules/manager';\nimport type { PackageDependency } from '../../../../modules/manager/types';\nimport { writeLocalFile } from '../../../../util/fs';\nimport { escapeRegExp, regEx } from '../../../../util/regex';\nimport { matchAt, replaceAt } from '../../../../util/string';\nimport { compile } from '../../../../util/template';\nimport type { BranchUpgradeConfig } from '../../../types';\n\nexport async function confirmIfDepUpdated(\n  upgrade: BranchUpgradeConfig,\n  newContent: string,\n): Promise<boolean> {\n  const { manager, packageFile, depIndex } = upgrade;\n  let newUpgrade: PackageDependency;\n  try {\n    const newExtract = await extractPackageFile(\n      manager,\n      newContent,\n      packageFile!,\n      upgrade,\n    );\n    // istanbul ignore if\n    if (!newExtract) {\n      // TODO: fix types (#22198)\n      logger.debug(\n        `Could not extract ${packageFile!} (manager=${manager}) after autoreplace. Did the autoreplace make the file unparseable?`,\n      );\n      logger.trace(\n        { packageFile, content: newContent },\n        'packageFile content after autoreplace',\n      );\n      return false;\n    }\n    // istanbul ignore if\n    if (!newExtract.deps?.length) {\n      logger.debug(\n        `Extracted ${packageFile!} after autoreplace has no deps array. Did the autoreplace make the file unparseable?`,\n      );\n      return false;\n    }\n    // istanbul ignore if\n    if (is.number(depIndex) && depIndex >= newExtract.deps.length) {\n      logger.debug(\n        `Extracted ${packageFile!} after autoreplace has fewer deps than expected.`,\n      );\n      return false;\n    }\n    newUpgrade = newExtract.deps[depIndex!];\n  } catch (err) /* istanbul ignore next */ {\n    logger.debug({ manager, packageFile, err }, 'Failed to parse newContent');\n  }\n\n  if (!newUpgrade!) {\n    logger.debug(`No newUpgrade in ${packageFile!}`);\n    return false;\n  }\n\n  if (\n    upgrade.depName !== newUpgrade.depName &&\n    upgrade.newName !== newUpgrade.depName\n  ) {\n    logger.debug(\n      {\n        manager,\n        packageFile,\n        currentDepName: upgrade.depName,\n        newDepName: newUpgrade.depName,\n      },\n      'depName mismatch',\n    );\n    return false;\n  }\n\n  if (upgrade.newName && upgrade.newName !== newUpgrade.depName) {\n    logger.debug(\n      {\n        manager,\n        packageFile,\n        currentDepName: upgrade.depName,\n        newDepName: newUpgrade.depName,\n      },\n      'depName is not updated',\n    );\n    return false;\n  }\n\n  if (upgrade.newValue && upgrade.newValue !== newUpgrade.currentValue) {\n    logger.debug(\n      {\n        manager,\n        packageFile,\n        expectedValue: upgrade.newValue,\n        foundValue: newUpgrade.currentValue,\n      },\n      'Value is not updated',\n    );\n    return false;\n  }\n\n  if (\n    upgrade.newDigest &&\n    (upgrade.isPinDigest === true || upgrade.currentDigest) &&\n    upgrade.newDigest !== newUpgrade.currentDigest\n  ) {\n    logger.debug(\n      {\n        manager,\n        packageFile,\n        expectedValue: upgrade.newDigest,\n        foundValue: newUpgrade.currentDigest,\n      },\n      'Digest is not updated',\n    );\n    return false;\n  }\n\n  return true;\n}\n\nfunction getDepsSignature(deps: PackageDependency[]): string {\n  // TODO: types (#22198)\n  return deps\n    .map(\n      (dep) =>\n        `${(dep.depName ?? dep.packageName)!}${(dep.packageName ??\n          dep.depName)!}`,\n    )\n    .join(',');\n}\n\nexport async function checkBranchDepsMatchBaseDeps(\n  upgrade: BranchUpgradeConfig,\n  branchContent: string,\n): Promise<boolean> {\n  const { baseDeps, manager, packageFile } = upgrade;\n  try {\n    const res = await extractPackageFile(\n      manager,\n      branchContent,\n      packageFile!,\n      upgrade,\n    )!;\n    const branchDeps = res!.deps;\n    return getDepsSignature(baseDeps!) === getDepsSignature(branchDeps);\n  } catch (err) /* istanbul ignore next */ {\n    logger.info(\n      { manager, packageFile },\n      'Failed to parse branchContent - rebasing',\n    );\n    return false;\n  }\n}\n\nasync function checkExistingBranch(\n  upgrade: BranchUpgradeConfig,\n  existingContent: string,\n): Promise<string | null> {\n  const { packageFile, depName } = upgrade;\n  if (!(await checkBranchDepsMatchBaseDeps(upgrade, existingContent))) {\n    logger.debug(\n      { packageFile, depName },\n      'Rebasing branch after deps list has changed',\n    );\n    return null;\n  }\n  if (!(await confirmIfDepUpdated(upgrade, existingContent))) {\n    logger.debug(\n      { packageFile, depName },\n      'Rebasing after outdated branch dep found',\n    );\n    return null;\n  }\n  // TODO: fix types (#22198)\n  logger.debug(`Branch dep ${depName!} in ${packageFile!} is already updated`);\n  return existingContent;\n}\n\nexport async function doAutoReplace(\n  upgrade: BranchUpgradeConfig,\n  existingContent: string,\n  reuseExistingBranch: boolean,\n  firstUpdate = true,\n): Promise<string | null> {\n  const {\n    packageFile,\n    depName,\n    newName,\n    currentValue,\n    newValue,\n    currentDigest,\n    currentDigestShort,\n    newDigest,\n    autoReplaceGlobalMatch,\n    autoReplaceStringTemplate,\n  } = upgrade;\n  /*\n    If replacement support for more managers is added,\n    please also update the list in docs/usage/configuration-options.md\n    at replacementName and replacementVersion\n  */\n  if (reuseExistingBranch) {\n    return await checkExistingBranch(upgrade, existingContent);\n  }\n  const replaceWithoutReplaceString =\n    is.string(newName) &&\n    newName !== depName &&\n    (is.undefined(upgrade.replaceString) ||\n      !upgrade.replaceString?.includes(depName!));\n  const replaceString = upgrade.replaceString ?? currentValue ?? currentDigest;\n  logger.trace({ depName, replaceString }, 'autoReplace replaceString');\n  let searchIndex: number;\n  if (replaceWithoutReplaceString) {\n    const depIndex = existingContent.indexOf(depName!);\n    const valIndex = existingContent.indexOf(currentValue!);\n    searchIndex = depIndex < valIndex ? depIndex : valIndex;\n  } else {\n    searchIndex = existingContent.indexOf(replaceString!);\n  }\n  if (searchIndex === -1) {\n    logger.info(\n      { packageFile, depName, existingContent, replaceString },\n      'Cannot find replaceString in current file content. Was it already updated?',\n    );\n    return existingContent;\n  }\n  try {\n    let newString: string;\n    if (autoReplaceStringTemplate && !newName) {\n      newString = compile(autoReplaceStringTemplate, upgrade, false);\n    } else {\n      newString = replaceString!;\n\n      const autoReplaceRegExpFlag = autoReplaceGlobalMatch ? 'g' : '';\n      if (currentValue && newValue) {\n        newString = newString.replace(\n          regEx(escapeRegExp(currentValue), autoReplaceRegExpFlag),\n          newValue,\n        );\n      }\n      if (depName && newName) {\n        newString = newString.replace(\n          regEx(escapeRegExp(depName), autoReplaceRegExpFlag),\n          newName,\n        );\n      }\n      if (currentDigest && newDigest) {\n        newString = newString.replace(\n          regEx(escapeRegExp(currentDigest), autoReplaceRegExpFlag),\n          newDigest,\n        );\n      } else if (currentDigestShort && newDigest) {\n        newString = newString.replace(\n          regEx(escapeRegExp(currentDigestShort), autoReplaceRegExpFlag),\n          newDigest,\n        );\n      }\n    }\n    if (!firstUpdate && (await confirmIfDepUpdated(upgrade, existingContent))) {\n      logger.debug(\n        { packageFile, depName },\n        'Package file is already updated - no work to do',\n      );\n      return existingContent;\n    }\n    logger.debug(\n      { packageFile, depName },\n      `Starting search at index ${searchIndex}`,\n    );\n    let newContent = existingContent;\n    let nameReplaced = !newName;\n    let valueReplaced = !newValue;\n    let startIndex = searchIndex;\n    // Iterate through the rest of the file\n    for (; searchIndex < newContent.length; searchIndex += 1) {\n      // First check if we have a hit for the old version\n      if (replaceWithoutReplaceString) {\n        // look for depName and currentValue\n        if (newName && matchAt(newContent, searchIndex, depName!)) {\n          logger.debug(\n            { packageFile, depName },\n            `Found depName at index ${searchIndex}`,\n          );\n          if (nameReplaced) {\n            startIndex += 1;\n            searchIndex = startIndex;\n            await writeLocalFile(upgrade.packageFile!, existingContent);\n            newContent = existingContent;\n            nameReplaced = false;\n            valueReplaced = false;\n            continue;\n          }\n          // replace with newName\n          newContent = replaceAt(newContent, searchIndex, depName!, newName);\n          await writeLocalFile(upgrade.packageFile!, newContent);\n          nameReplaced = true;\n        } else if (\n          newValue &&\n          matchAt(newContent, searchIndex, currentValue!)\n        ) {\n          logger.debug(\n            { packageFile, currentValue },\n            `Found currentValue at index ${searchIndex}`,\n          );\n          // Now test if the result matches\n          newContent = replaceAt(\n            newContent,\n            searchIndex,\n            currentValue!,\n            newValue,\n          );\n          await writeLocalFile(upgrade.packageFile!, newContent);\n          valueReplaced = true;\n        }\n        if (nameReplaced && valueReplaced) {\n          if (await confirmIfDepUpdated(upgrade, newContent)) {\n            return newContent;\n          }\n          await writeLocalFile(upgrade.packageFile!, existingContent);\n          newContent = existingContent;\n          nameReplaced = false;\n          valueReplaced = false;\n        }\n      } else if (matchAt(newContent, searchIndex, replaceString!)) {\n        logger.debug(\n          { packageFile, depName },\n          `Found match at index ${searchIndex}`,\n        );\n        // Now test if the result matches\n        newContent = replaceAt(\n          newContent,\n          searchIndex,\n          replaceString!,\n          newString,\n        );\n        await writeLocalFile(upgrade.packageFile!, newContent);\n        if (await confirmIfDepUpdated(upgrade, newContent)) {\n          return newContent;\n        }\n        await writeLocalFile(upgrade.packageFile!, existingContent);\n        newContent = existingContent;\n      }\n    }\n  } catch (err) /* istanbul ignore next */ {\n    logger.debug({ packageFile, depName, err }, 'doAutoReplace error');\n  }\n  // istanbul ignore next\n  throw new Error(WORKER_FILE_UPDATE_FAILED);\n}\n"]}