{"version":3,"file":"package-rules-migration.js","sourceRoot":"","sources":["../../../../lib/config/migrations/custom/package-rules-migration.ts"],"names":[],"mappings":";;;;AAAA,kEAAkC;AAElC,mEAA+D;AAElD,QAAA,SAAS,GAAG;IACvB,UAAU,EAAE,gBAAgB;IAC5B,UAAU,EAAE,gBAAgB;IAC5B,KAAK,EAAE,gBAAgB;IACvB,SAAS,EAAE,iBAAiB;IAC5B,cAAc,EAAE,iBAAiB;IACjC,cAAc,EAAE,mBAAmB;IACnC,QAAQ,EAAE,eAAe;IACzB,WAAW,EAAE,kBAAkB;IAC/B,WAAW,EAAE,eAAe;IAC5B,YAAY,EAAE,mBAAmB;IACjC,eAAe,EAAE,sBAAsB;IACvC,iBAAiB,EAAE,wBAAwB;IAC3C,WAAW,EAAE,kBAAkB;CAChC,CAAC;AAGF,SAAS,UAAU,CAAC,WAAwB;IAC1C,MAAM,cAAc,GAAgB,EAAE,CAAC;IACvC,KAAK,MAAM,CAAC,GAAG,EAAE,GAAG,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,WAAW,CAAC,EAAE,CAAC;QACrD,cAAc,CAAC,iBAAS,CAAC,GAAmB,CAAC,IAAI,GAAG,CAAC,GAAG,GAAG,CAAC;IAC9D,CAAC;IACD,OAAO,cAAc,CAAC;AACxB,CAAC;AAED,MAAa,qBAAsB,SAAQ,sCAAiB;IACxC,YAAY,GAAG,cAAc,CAAC;IAEvC,GAAG,CAAC,KAAc;QACzB,IAAI,YAAY,GAAG,IAAI,CAAC,GAAG,CAAC,cAAc,CAAkB,CAAC;QAC7D,IAAI,YAAE,CAAC,aAAa,CAAC,YAAY,CAAC,EAAE,CAAC;YACnC,YAAY,GAAG,YAAY,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;YAE5C,IAAI,CAAC,OAAO,CAAC,YAAY,CAAC,CAAC;QAC7B,CAAC;IACH,CAAC;CACF;AAXD,sDAWC","sourcesContent":["import is from '@sindresorhus/is';\nimport type { PackageRule } from '../../types';\nimport { AbstractMigration } from '../base/abstract-migration';\n\nexport const renameMap = {\n  matchFiles: 'matchFileNames',\n  matchPaths: 'matchFileNames',\n  paths: 'matchFileNames',\n  languages: 'matchCategories',\n  matchLanguages: 'matchCategories',\n  baseBranchList: 'matchBaseBranches',\n  managers: 'matchManagers',\n  datasources: 'matchDatasources',\n  depTypeList: 'matchDepTypes',\n  packageNames: 'matchPackageNames',\n  packagePatterns: 'matchPackagePatterns',\n  sourceUrlPrefixes: 'matchSourceUrlPrefixes',\n  updateTypes: 'matchUpdateTypes',\n};\ntype RenameMapKey = keyof typeof renameMap;\n\nfunction renameKeys(packageRule: PackageRule): PackageRule {\n  const newPackageRule: PackageRule = {};\n  for (const [key, val] of Object.entries(packageRule)) {\n    newPackageRule[renameMap[key as RenameMapKey] ?? key] = val;\n  }\n  return newPackageRule;\n}\n\nexport class PackageRulesMigration extends AbstractMigration {\n  override readonly propertyName = 'packageRules';\n\n  override run(value: unknown): void {\n    let packageRules = this.get('packageRules') as PackageRule[];\n    if (is.nonEmptyArray(packageRules)) {\n      packageRules = packageRules.map(renameKeys);\n\n      this.rewrite(packageRules);\n    }\n  }\n}\n"]}